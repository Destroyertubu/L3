/**
 * Autogenerated by Thrift Compiler (0.19.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "heavy_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kTExecuteModeValues[] = {
  TExecuteMode::GPU,
  TExecuteMode::CPU
};
const char* _kTExecuteModeNames[] = {
  "GPU",
  "CPU"
};
const std::map<int, const char*> _TExecuteMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTExecuteModeValues, _kTExecuteModeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TExecuteMode::type& val) {
  std::map<int, const char*>::const_iterator it = _TExecuteMode_VALUES_TO_NAMES.find(val);
  if (it != _TExecuteMode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TExecuteMode::type& val) {
  std::map<int, const char*>::const_iterator it = _TExecuteMode_VALUES_TO_NAMES.find(val);
  if (it != _TExecuteMode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTSourceTypeValues[] = {
  TSourceType::DELIMITED_FILE,
  TSourceType::GEO_FILE,
  TSourceType::PARQUET_FILE,
  TSourceType::RASTER_FILE,
  TSourceType::ODBC
};
const char* _kTSourceTypeNames[] = {
  "DELIMITED_FILE",
  "GEO_FILE",
  "PARQUET_FILE",
  "RASTER_FILE",
  "ODBC"
};
const std::map<int, const char*> _TSourceType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTSourceTypeValues, _kTSourceTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TSourceType::type& val) {
  std::map<int, const char*>::const_iterator it = _TSourceType_VALUES_TO_NAMES.find(val);
  if (it != _TSourceType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TSourceType::type& val) {
  std::map<int, const char*>::const_iterator it = _TSourceType_VALUES_TO_NAMES.find(val);
  if (it != _TSourceType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTPartitionDetailValues[] = {
  TPartitionDetail::DEFAULT,
  TPartitionDetail::REPLICATED,
  TPartitionDetail::SHARDED,
  TPartitionDetail::OTHER
};
const char* _kTPartitionDetailNames[] = {
  "DEFAULT",
  "REPLICATED",
  "SHARDED",
  "OTHER"
};
const std::map<int, const char*> _TPartitionDetail_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTPartitionDetailValues, _kTPartitionDetailNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TPartitionDetail::type& val) {
  std::map<int, const char*>::const_iterator it = _TPartitionDetail_VALUES_TO_NAMES.find(val);
  if (it != _TPartitionDetail_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TPartitionDetail::type& val) {
  std::map<int, const char*>::const_iterator it = _TPartitionDetail_VALUES_TO_NAMES.find(val);
  if (it != _TPartitionDetail_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTGeoFileLayerContentsValues[] = {
  TGeoFileLayerContents::EMPTY,
  TGeoFileLayerContents::GEO,
  TGeoFileLayerContents::NON_GEO,
  TGeoFileLayerContents::UNSUPPORTED_GEO
};
const char* _kTGeoFileLayerContentsNames[] = {
  "EMPTY",
  "GEO",
  "NON_GEO",
  "UNSUPPORTED_GEO"
};
const std::map<int, const char*> _TGeoFileLayerContents_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTGeoFileLayerContentsValues, _kTGeoFileLayerContentsNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TGeoFileLayerContents::type& val) {
  std::map<int, const char*>::const_iterator it = _TGeoFileLayerContents_VALUES_TO_NAMES.find(val);
  if (it != _TGeoFileLayerContents_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TGeoFileLayerContents::type& val) {
  std::map<int, const char*>::const_iterator it = _TGeoFileLayerContents_VALUES_TO_NAMES.find(val);
  if (it != _TGeoFileLayerContents_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTImportHeaderRowValues[] = {
  TImportHeaderRow::AUTODETECT,
  TImportHeaderRow::NO_HEADER,
  TImportHeaderRow::HAS_HEADER
};
const char* _kTImportHeaderRowNames[] = {
  "AUTODETECT",
  "NO_HEADER",
  "HAS_HEADER"
};
const std::map<int, const char*> _TImportHeaderRow_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTImportHeaderRowValues, _kTImportHeaderRowNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TImportHeaderRow::type& val) {
  std::map<int, const char*>::const_iterator it = _TImportHeaderRow_VALUES_TO_NAMES.find(val);
  if (it != _TImportHeaderRow_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TImportHeaderRow::type& val) {
  std::map<int, const char*>::const_iterator it = _TImportHeaderRow_VALUES_TO_NAMES.find(val);
  if (it != _TImportHeaderRow_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTRoleValues[] = {
  TRole::SERVER,
  TRole::AGGREGATOR,
  TRole::LEAF,
  TRole::STRING_DICTIONARY
};
const char* _kTRoleNames[] = {
  "SERVER",
  "AGGREGATOR",
  "LEAF",
  "STRING_DICTIONARY"
};
const std::map<int, const char*> _TRole_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTRoleValues, _kTRoleNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TRole::type& val) {
  std::map<int, const char*>::const_iterator it = _TRole_VALUES_TO_NAMES.find(val);
  if (it != _TRole_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TRole::type& val) {
  std::map<int, const char*>::const_iterator it = _TRole_VALUES_TO_NAMES.find(val);
  if (it != _TRole_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTTableTypeValues[] = {
  TTableType::DEFAULT,
  TTableType::TEMPORARY,
  TTableType::FOREIGN,
  TTableType::VIEW
};
const char* _kTTableTypeNames[] = {
  "DEFAULT",
  "TEMPORARY",
  "FOREIGN",
  "VIEW"
};
const std::map<int, const char*> _TTableType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTTableTypeValues, _kTTableTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TTableType::type& val) {
  std::map<int, const char*>::const_iterator it = _TTableType_VALUES_TO_NAMES.find(val);
  if (it != _TTableType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TTableType::type& val) {
  std::map<int, const char*>::const_iterator it = _TTableType_VALUES_TO_NAMES.find(val);
  if (it != _TTableType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTTableRefreshUpdateTypeValues[] = {
  TTableRefreshUpdateType::ALL,
  TTableRefreshUpdateType::APPEND
};
const char* _kTTableRefreshUpdateTypeNames[] = {
  "ALL",
  "APPEND"
};
const std::map<int, const char*> _TTableRefreshUpdateType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTTableRefreshUpdateTypeValues, _kTTableRefreshUpdateTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TTableRefreshUpdateType::type& val) {
  std::map<int, const char*>::const_iterator it = _TTableRefreshUpdateType_VALUES_TO_NAMES.find(val);
  if (it != _TTableRefreshUpdateType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TTableRefreshUpdateType::type& val) {
  std::map<int, const char*>::const_iterator it = _TTableRefreshUpdateType_VALUES_TO_NAMES.find(val);
  if (it != _TTableRefreshUpdateType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTTableRefreshTimingTypeValues[] = {
  TTableRefreshTimingType::MANUAL,
  TTableRefreshTimingType::SCHEDULED
};
const char* _kTTableRefreshTimingTypeNames[] = {
  "MANUAL",
  "SCHEDULED"
};
const std::map<int, const char*> _TTableRefreshTimingType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTTableRefreshTimingTypeValues, _kTTableRefreshTimingTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TTableRefreshTimingType::type& val) {
  std::map<int, const char*>::const_iterator it = _TTableRefreshTimingType_VALUES_TO_NAMES.find(val);
  if (it != _TTableRefreshTimingType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TTableRefreshTimingType::type& val) {
  std::map<int, const char*>::const_iterator it = _TTableRefreshTimingType_VALUES_TO_NAMES.find(val);
  if (it != _TTableRefreshTimingType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTTableRefreshIntervalTypeValues[] = {
  TTableRefreshIntervalType::NONE,
  TTableRefreshIntervalType::HOUR,
  TTableRefreshIntervalType::DAY
};
const char* _kTTableRefreshIntervalTypeNames[] = {
  "NONE",
  "HOUR",
  "DAY"
};
const std::map<int, const char*> _TTableRefreshIntervalType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTTableRefreshIntervalTypeValues, _kTTableRefreshIntervalTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TTableRefreshIntervalType::type& val) {
  std::map<int, const char*>::const_iterator it = _TTableRefreshIntervalType_VALUES_TO_NAMES.find(val);
  if (it != _TTableRefreshIntervalType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TTableRefreshIntervalType::type& val) {
  std::map<int, const char*>::const_iterator it = _TTableRefreshIntervalType_VALUES_TO_NAMES.find(val);
  if (it != _TTableRefreshIntervalType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTMergeTypeValues[] = {
  TMergeType::UNION,
  TMergeType::REDUCE
};
const char* _kTMergeTypeNames[] = {
  "UNION",
  "REDUCE"
};
const std::map<int, const char*> _TMergeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTMergeTypeValues, _kTMergeTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TMergeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TMergeType_VALUES_TO_NAMES.find(val);
  if (it != _TMergeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TMergeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TMergeType_VALUES_TO_NAMES.find(val);
  if (it != _TMergeType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTRasterPointTypeValues[] = {
  TRasterPointType::NONE,
  TRasterPointType::AUTO,
  TRasterPointType::SMALLINT,
  TRasterPointType::INT,
  TRasterPointType::FLOAT,
  TRasterPointType::DOUBLE,
  TRasterPointType::POINT
};
const char* _kTRasterPointTypeNames[] = {
  "NONE",
  "AUTO",
  "SMALLINT",
  "INT",
  "FLOAT",
  "DOUBLE",
  "POINT"
};
const std::map<int, const char*> _TRasterPointType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTRasterPointTypeValues, _kTRasterPointTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TRasterPointType::type& val) {
  std::map<int, const char*>::const_iterator it = _TRasterPointType_VALUES_TO_NAMES.find(val);
  if (it != _TRasterPointType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TRasterPointType::type& val) {
  std::map<int, const char*>::const_iterator it = _TRasterPointType_VALUES_TO_NAMES.find(val);
  if (it != _TRasterPointType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTRasterPointTransformValues[] = {
  TRasterPointTransform::NONE,
  TRasterPointTransform::AUTO,
  TRasterPointTransform::FILE,
  TRasterPointTransform::WORLD
};
const char* _kTRasterPointTransformNames[] = {
  "NONE",
  "AUTO",
  "FILE",
  "WORLD"
};
const std::map<int, const char*> _TRasterPointTransform_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTRasterPointTransformValues, _kTRasterPointTransformNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TRasterPointTransform::type& val) {
  std::map<int, const char*>::const_iterator it = _TRasterPointTransform_VALUES_TO_NAMES.find(val);
  if (it != _TRasterPointTransform_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TRasterPointTransform::type& val) {
  std::map<int, const char*>::const_iterator it = _TRasterPointTransform_VALUES_TO_NAMES.find(val);
  if (it != _TRasterPointTransform_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTQueryTypeValues[] = {
  TQueryType::UNKNOWN,
  TQueryType::READ,
  TQueryType::WRITE,
  TQueryType::SCHEMA_READ,
  TQueryType::SCHEMA_WRITE
};
const char* _kTQueryTypeNames[] = {
  "UNKNOWN",
  "READ",
  "WRITE",
  "SCHEMA_READ",
  "SCHEMA_WRITE"
};
const std::map<int, const char*> _TQueryType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTQueryTypeValues, _kTQueryTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TQueryType::type& val) {
  std::map<int, const char*>::const_iterator it = _TQueryType_VALUES_TO_NAMES.find(val);
  if (it != _TQueryType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TQueryType::type& val) {
  std::map<int, const char*>::const_iterator it = _TQueryType_VALUES_TO_NAMES.find(val);
  if (it != _TQueryType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTArrowTransportValues[] = {
  TArrowTransport::SHARED_MEMORY,
  TArrowTransport::WIRE
};
const char* _kTArrowTransportNames[] = {
  "SHARED_MEMORY",
  "WIRE"
};
const std::map<int, const char*> _TArrowTransport_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTArrowTransportValues, _kTArrowTransportNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TArrowTransport::type& val) {
  std::map<int, const char*>::const_iterator it = _TArrowTransport_VALUES_TO_NAMES.find(val);
  if (it != _TArrowTransport_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TArrowTransport::type& val) {
  std::map<int, const char*>::const_iterator it = _TArrowTransport_VALUES_TO_NAMES.find(val);
  if (it != _TArrowTransport_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTExpressionRangeTypeValues[] = {
  TExpressionRangeType::INVALID,
  TExpressionRangeType::INTEGER,
  TExpressionRangeType::FLOAT,
  TExpressionRangeType::DOUBLE
};
const char* _kTExpressionRangeTypeNames[] = {
  "INVALID",
  "INTEGER",
  "FLOAT",
  "DOUBLE"
};
const std::map<int, const char*> _TExpressionRangeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTExpressionRangeTypeValues, _kTExpressionRangeTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TExpressionRangeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TExpressionRangeType_VALUES_TO_NAMES.find(val);
  if (it != _TExpressionRangeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TExpressionRangeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TExpressionRangeType_VALUES_TO_NAMES.find(val);
  if (it != _TExpressionRangeType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTDBObjectTypeValues[] = {
  TDBObjectType::AbstractDBObjectType,
  TDBObjectType::DatabaseDBObjectType,
  TDBObjectType::TableDBObjectType,
  TDBObjectType::DashboardDBObjectType,
  TDBObjectType::ViewDBObjectType,
  TDBObjectType::ServerDBObjectType,
  TDBObjectType::ColumnDBObjectType
};
const char* _kTDBObjectTypeNames[] = {
  "AbstractDBObjectType",
  "DatabaseDBObjectType",
  "TableDBObjectType",
  "DashboardDBObjectType",
  "ViewDBObjectType",
  "ServerDBObjectType",
  "ColumnDBObjectType"
};
const std::map<int, const char*> _TDBObjectType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTDBObjectTypeValues, _kTDBObjectTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TDBObjectType::type& val) {
  std::map<int, const char*>::const_iterator it = _TDBObjectType_VALUES_TO_NAMES.find(val);
  if (it != _TDBObjectType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TDBObjectType::type& val) {
  std::map<int, const char*>::const_iterator it = _TDBObjectType_VALUES_TO_NAMES.find(val);
  if (it != _TDBObjectType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTDataSourceTypeValues[] = {
  TDataSourceType::TABLE
};
const char* _kTDataSourceTypeNames[] = {
  "TABLE"
};
const std::map<int, const char*> _TDataSourceType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kTDataSourceTypeValues, _kTDataSourceTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TDataSourceType::type& val) {
  std::map<int, const char*>::const_iterator it = _TDataSourceType_VALUES_TO_NAMES.find(val);
  if (it != _TDataSourceType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TDataSourceType::type& val) {
  std::map<int, const char*>::const_iterator it = _TDataSourceType_VALUES_TO_NAMES.find(val);
  if (it != _TDataSourceType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


TDatumVal::~TDatumVal() noexcept {
}


void TDatumVal::__set_int_val(const int64_t val) {
  this->int_val = val;
}

void TDatumVal::__set_real_val(const double val) {
  this->real_val = val;
}

void TDatumVal::__set_str_val(const std::string& val) {
  this->str_val = val;
}

void TDatumVal::__set_arr_val(const std::vector<TDatum> & val) {
  this->arr_val = val;
}
std::ostream& operator<<(std::ostream& out, const TDatumVal& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDatumVal::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_val);
          this->__isset.int_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->real_val);
          this->__isset.real_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->str_val);
          this->__isset.str_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arr_val.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->arr_val.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->arr_val[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arr_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDatumVal::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDatumVal");

  xfer += oprot->writeFieldBegin("int_val", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->int_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("real_val", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->real_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("str_val", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->str_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arr_val", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arr_val.size()));
    std::vector<TDatum> ::const_iterator _iter5;
    for (_iter5 = this->arr_val.begin(); _iter5 != this->arr_val.end(); ++_iter5)
    {
      xfer += (*_iter5).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDatumVal &a, TDatumVal &b) {
  using ::std::swap;
  swap(a.int_val, b.int_val);
  swap(a.real_val, b.real_val);
  swap(a.str_val, b.str_val);
  swap(a.arr_val, b.arr_val);
  swap(a.__isset, b.__isset);
}

TDatumVal::TDatumVal(const TDatumVal& other6) {
  int_val = other6.int_val;
  real_val = other6.real_val;
  str_val = other6.str_val;
  arr_val = other6.arr_val;
  __isset = other6.__isset;
}
TDatumVal& TDatumVal::operator=(const TDatumVal& other7) {
  int_val = other7.int_val;
  real_val = other7.real_val;
  str_val = other7.str_val;
  arr_val = other7.arr_val;
  __isset = other7.__isset;
  return *this;
}
void TDatumVal::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDatumVal(";
  out << "int_val=" << to_string(int_val);
  out << ", " << "real_val=" << to_string(real_val);
  out << ", " << "str_val=" << to_string(str_val);
  out << ", " << "arr_val=" << to_string(arr_val);
  out << ")";
}


TDatum::~TDatum() noexcept {
}


void TDatum::__set_val(const TDatumVal& val) {
  this->val = val;
}

void TDatum::__set_is_null(const bool val) {
  this->is_null = val;
}
std::ostream& operator<<(std::ostream& out, const TDatum& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDatum::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->val.read(iprot);
          this->__isset.val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          this->__isset.is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDatum::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDatum");

  xfer += oprot->writeFieldBegin("val", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->val.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDatum &a, TDatum &b) {
  using ::std::swap;
  swap(a.val, b.val);
  swap(a.is_null, b.is_null);
  swap(a.__isset, b.__isset);
}

TDatum::TDatum(const TDatum& other8) {
  val = other8.val;
  is_null = other8.is_null;
  __isset = other8.__isset;
}
TDatum& TDatum::operator=(const TDatum& other9) {
  val = other9.val;
  is_null = other9.is_null;
  __isset = other9.__isset;
  return *this;
}
void TDatum::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDatum(";
  out << "val=" << to_string(val);
  out << ", " << "is_null=" << to_string(is_null);
  out << ")";
}


TStringValue::~TStringValue() noexcept {
}


void TStringValue::__set_str_val(const std::string& val) {
  this->str_val = val;
}

void TStringValue::__set_is_null(const bool val) {
  this->is_null = val;
}
std::ostream& operator<<(std::ostream& out, const TStringValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStringValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->str_val);
          this->__isset.str_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          this->__isset.is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringValue");

  xfer += oprot->writeFieldBegin("str_val", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->str_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStringValue &a, TStringValue &b) {
  using ::std::swap;
  swap(a.str_val, b.str_val);
  swap(a.is_null, b.is_null);
  swap(a.__isset, b.__isset);
}

TStringValue::TStringValue(const TStringValue& other10) {
  str_val = other10.str_val;
  is_null = other10.is_null;
  __isset = other10.__isset;
}
TStringValue& TStringValue::operator=(const TStringValue& other11) {
  str_val = other11.str_val;
  is_null = other11.is_null;
  __isset = other11.__isset;
  return *this;
}
void TStringValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStringValue(";
  out << "str_val=" << to_string(str_val);
  out << ", " << "is_null=" << to_string(is_null);
  out << ")";
}


TColumnType::~TColumnType() noexcept {
}


void TColumnType::__set_col_name(const std::string& val) {
  this->col_name = val;
}

void TColumnType::__set_col_type(const  ::TTypeInfo& val) {
  this->col_type = val;
}

void TColumnType::__set_is_reserved_keyword(const bool val) {
  this->is_reserved_keyword = val;
}

void TColumnType::__set_src_name(const std::string& val) {
  this->src_name = val;
}

void TColumnType::__set_is_system(const bool val) {
  this->is_system = val;
}

void TColumnType::__set_is_physical(const bool val) {
  this->is_physical = val;
}

void TColumnType::__set_col_id(const int64_t val) {
  this->col_id = val;
}

void TColumnType::__set_default_value(const std::string& val) {
  this->default_value = val;
__isset.default_value = true;
}

void TColumnType::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}
std::ostream& operator<<(std::ostream& out, const TColumnType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col_name);
          this->__isset.col_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->col_type.read(iprot);
          this->__isset.col_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_reserved_keyword);
          this->__isset.is_reserved_keyword = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->src_name);
          this->__isset.src_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system);
          this->__isset.is_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_physical);
          this->__isset.is_physical = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->col_id);
          this->__isset.col_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->default_value);
          this->__isset.default_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnType");

  xfer += oprot->writeFieldBegin("col_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->col_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_type", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->col_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_reserved_keyword", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_reserved_keyword);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->src_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_system", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_system);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_physical", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->is_physical);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_id", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->col_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.default_value) {
    xfer += oprot->writeFieldBegin("default_value", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->default_value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnType &a, TColumnType &b) {
  using ::std::swap;
  swap(a.col_name, b.col_name);
  swap(a.col_type, b.col_type);
  swap(a.is_reserved_keyword, b.is_reserved_keyword);
  swap(a.src_name, b.src_name);
  swap(a.is_system, b.is_system);
  swap(a.is_physical, b.is_physical);
  swap(a.col_id, b.col_id);
  swap(a.default_value, b.default_value);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

TColumnType::TColumnType(const TColumnType& other12) {
  col_name = other12.col_name;
  col_type = other12.col_type;
  is_reserved_keyword = other12.is_reserved_keyword;
  src_name = other12.src_name;
  is_system = other12.is_system;
  is_physical = other12.is_physical;
  col_id = other12.col_id;
  default_value = other12.default_value;
  comment = other12.comment;
  __isset = other12.__isset;
}
TColumnType& TColumnType::operator=(const TColumnType& other13) {
  col_name = other13.col_name;
  col_type = other13.col_type;
  is_reserved_keyword = other13.is_reserved_keyword;
  src_name = other13.src_name;
  is_system = other13.is_system;
  is_physical = other13.is_physical;
  col_id = other13.col_id;
  default_value = other13.default_value;
  comment = other13.comment;
  __isset = other13.__isset;
  return *this;
}
void TColumnType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnType(";
  out << "col_name=" << to_string(col_name);
  out << ", " << "col_type=" << to_string(col_type);
  out << ", " << "is_reserved_keyword=" << to_string(is_reserved_keyword);
  out << ", " << "src_name=" << to_string(src_name);
  out << ", " << "is_system=" << to_string(is_system);
  out << ", " << "is_physical=" << to_string(is_physical);
  out << ", " << "col_id=" << to_string(col_id);
  out << ", " << "default_value="; (__isset.default_value ? (out << to_string(default_value)) : (out << "<null>"));
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ")";
}


TRow::~TRow() noexcept {
}


void TRow::__set_cols(const std::vector<TDatum> & val) {
  this->cols = val;
}
std::ostream& operator<<(std::ostream& out, const TRow& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRow::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cols.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->cols.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += this->cols[_i18].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRow");

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cols.size()));
    std::vector<TDatum> ::const_iterator _iter19;
    for (_iter19 = this->cols.begin(); _iter19 != this->cols.end(); ++_iter19)
    {
      xfer += (*_iter19).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRow &a, TRow &b) {
  using ::std::swap;
  swap(a.cols, b.cols);
  swap(a.__isset, b.__isset);
}

TRow::TRow(const TRow& other20) {
  cols = other20.cols;
  __isset = other20.__isset;
}
TRow& TRow::operator=(const TRow& other21) {
  cols = other21.cols;
  __isset = other21.__isset;
  return *this;
}
void TRow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRow(";
  out << "cols=" << to_string(cols);
  out << ")";
}


TColumnData::~TColumnData() noexcept {
}


void TColumnData::__set_int_col(const std::vector<int64_t> & val) {
  this->int_col = val;
}

void TColumnData::__set_real_col(const std::vector<double> & val) {
  this->real_col = val;
}

void TColumnData::__set_str_col(const std::vector<std::string> & val) {
  this->str_col = val;
}

void TColumnData::__set_arr_col(const std::vector<TColumn> & val) {
  this->arr_col = val;
}
std::ostream& operator<<(std::ostream& out, const TColumnData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->int_col.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->int_col.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += iprot->readI64(this->int_col[_i26]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.int_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->real_col.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->real_col.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += iprot->readDouble(this->real_col[_i31]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.real_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->str_col.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->str_col.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += iprot->readString(this->str_col[_i36]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.str_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arr_col.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->arr_col.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += this->arr_col[_i41].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arr_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnData");

  xfer += oprot->writeFieldBegin("int_col", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->int_col.size()));
    std::vector<int64_t> ::const_iterator _iter42;
    for (_iter42 = this->int_col.begin(); _iter42 != this->int_col.end(); ++_iter42)
    {
      xfer += oprot->writeI64((*_iter42));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("real_col", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->real_col.size()));
    std::vector<double> ::const_iterator _iter43;
    for (_iter43 = this->real_col.begin(); _iter43 != this->real_col.end(); ++_iter43)
    {
      xfer += oprot->writeDouble((*_iter43));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("str_col", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->str_col.size()));
    std::vector<std::string> ::const_iterator _iter44;
    for (_iter44 = this->str_col.begin(); _iter44 != this->str_col.end(); ++_iter44)
    {
      xfer += oprot->writeString((*_iter44));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arr_col", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arr_col.size()));
    std::vector<TColumn> ::const_iterator _iter45;
    for (_iter45 = this->arr_col.begin(); _iter45 != this->arr_col.end(); ++_iter45)
    {
      xfer += (*_iter45).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnData &a, TColumnData &b) {
  using ::std::swap;
  swap(a.int_col, b.int_col);
  swap(a.real_col, b.real_col);
  swap(a.str_col, b.str_col);
  swap(a.arr_col, b.arr_col);
  swap(a.__isset, b.__isset);
}

TColumnData::TColumnData(const TColumnData& other46) {
  int_col = other46.int_col;
  real_col = other46.real_col;
  str_col = other46.str_col;
  arr_col = other46.arr_col;
  __isset = other46.__isset;
}
TColumnData& TColumnData::operator=(const TColumnData& other47) {
  int_col = other47.int_col;
  real_col = other47.real_col;
  str_col = other47.str_col;
  arr_col = other47.arr_col;
  __isset = other47.__isset;
  return *this;
}
void TColumnData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnData(";
  out << "int_col=" << to_string(int_col);
  out << ", " << "real_col=" << to_string(real_col);
  out << ", " << "str_col=" << to_string(str_col);
  out << ", " << "arr_col=" << to_string(arr_col);
  out << ")";
}


TColumn::~TColumn() noexcept {
}


void TColumn::__set_data(const TColumnData& val) {
  this->data = val;
}

void TColumn::__set_nulls(const std::vector<bool> & val) {
  this->nulls = val;
}
std::ostream& operator<<(std::ostream& out, const TColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nulls.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->nulls.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += iprot->readBool(this->nulls[_i52]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumn");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->nulls.size()));
    std::vector<bool> ::const_iterator _iter53;
    for (_iter53 = this->nulls.begin(); _iter53 != this->nulls.end(); ++_iter53)
    {
      xfer += oprot->writeBool((*_iter53));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumn &a, TColumn &b) {
  using ::std::swap;
  swap(a.data, b.data);
  swap(a.nulls, b.nulls);
  swap(a.__isset, b.__isset);
}

TColumn::TColumn(const TColumn& other54) {
  data = other54.data;
  nulls = other54.nulls;
  __isset = other54.__isset;
}
TColumn& TColumn::operator=(const TColumn& other55) {
  data = other55.data;
  nulls = other55.nulls;
  __isset = other55.__isset;
  return *this;
}
void TColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumn(";
  out << "data=" << to_string(data);
  out << ", " << "nulls=" << to_string(nulls);
  out << ")";
}


TStringRow::~TStringRow() noexcept {
}


void TStringRow::__set_cols(const std::vector<TStringValue> & val) {
  this->cols = val;
}
std::ostream& operator<<(std::ostream& out, const TStringRow& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStringRow::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cols.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _etype59;
            xfer += iprot->readListBegin(_etype59, _size56);
            this->cols.resize(_size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              xfer += this->cols[_i60].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringRow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringRow");

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cols.size()));
    std::vector<TStringValue> ::const_iterator _iter61;
    for (_iter61 = this->cols.begin(); _iter61 != this->cols.end(); ++_iter61)
    {
      xfer += (*_iter61).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStringRow &a, TStringRow &b) {
  using ::std::swap;
  swap(a.cols, b.cols);
  swap(a.__isset, b.__isset);
}

TStringRow::TStringRow(const TStringRow& other62) {
  cols = other62.cols;
  __isset = other62.__isset;
}
TStringRow& TStringRow::operator=(const TStringRow& other63) {
  cols = other63.cols;
  __isset = other63.__isset;
  return *this;
}
void TStringRow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStringRow(";
  out << "cols=" << to_string(cols);
  out << ")";
}


TKrb5Session::~TKrb5Session() noexcept {
}


void TKrb5Session::__set_sessionId(const TSessionId& val) {
  this->sessionId = val;
}

void TKrb5Session::__set_krbToken(const TKrb5Token& val) {
  this->krbToken = val;
}
std::ostream& operator<<(std::ostream& out, const TKrb5Session& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TKrb5Session::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sessionId);
          this->__isset.sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->krbToken);
          this->__isset.krbToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TKrb5Session::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKrb5Session");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("krbToken", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->krbToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TKrb5Session &a, TKrb5Session &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.krbToken, b.krbToken);
  swap(a.__isset, b.__isset);
}

TKrb5Session::TKrb5Session(const TKrb5Session& other64) {
  sessionId = other64.sessionId;
  krbToken = other64.krbToken;
  __isset = other64.__isset;
}
TKrb5Session& TKrb5Session::operator=(const TKrb5Session& other65) {
  sessionId = other65.sessionId;
  krbToken = other65.krbToken;
  __isset = other65.__isset;
  return *this;
}
void TKrb5Session::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKrb5Session(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "krbToken=" << to_string(krbToken);
  out << ")";
}


TStepResult::~TStepResult() noexcept {
}


void TStepResult::__set_serialized_rows(const  ::TSerializedRows& val) {
  this->serialized_rows = val;
}

void TStepResult::__set_execution_finished(const bool val) {
  this->execution_finished = val;
}

void TStepResult::__set_merge_type(const TMergeType::type val) {
  this->merge_type = val;
}

void TStepResult::__set_sharded(const bool val) {
  this->sharded = val;
}

void TStepResult::__set_row_desc(const TRowDescriptor& val) {
  this->row_desc = val;
}

void TStepResult::__set_node_id(const int32_t val) {
  this->node_id = val;
}
std::ostream& operator<<(std::ostream& out, const TStepResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStepResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serialized_rows.read(iprot);
          this->__isset.serialized_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->execution_finished);
          this->__isset.execution_finished = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast66;
          xfer += iprot->readI32(ecast66);
          this->merge_type = static_cast<TMergeType::type>(ecast66);
          this->__isset.merge_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sharded);
          this->__isset.sharded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_desc.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _etype70;
            xfer += iprot->readListBegin(_etype70, _size67);
            this->row_desc.resize(_size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              xfer += this->row_desc[_i71].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStepResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStepResult");

  xfer += oprot->writeFieldBegin("serialized_rows", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->serialized_rows.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_finished", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->execution_finished);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("merge_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(static_cast<int32_t>(this->merge_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sharded", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->sharded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_desc", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_desc.size()));
    std::vector<TColumnType> ::const_iterator _iter72;
    for (_iter72 = this->row_desc.begin(); _iter72 != this->row_desc.end(); ++_iter72)
    {
      xfer += (*_iter72).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStepResult &a, TStepResult &b) {
  using ::std::swap;
  swap(a.serialized_rows, b.serialized_rows);
  swap(a.execution_finished, b.execution_finished);
  swap(a.merge_type, b.merge_type);
  swap(a.sharded, b.sharded);
  swap(a.row_desc, b.row_desc);
  swap(a.node_id, b.node_id);
  swap(a.__isset, b.__isset);
}

TStepResult::TStepResult(const TStepResult& other73) {
  serialized_rows = other73.serialized_rows;
  execution_finished = other73.execution_finished;
  merge_type = other73.merge_type;
  sharded = other73.sharded;
  row_desc = other73.row_desc;
  node_id = other73.node_id;
  __isset = other73.__isset;
}
TStepResult& TStepResult::operator=(const TStepResult& other74) {
  serialized_rows = other74.serialized_rows;
  execution_finished = other74.execution_finished;
  merge_type = other74.merge_type;
  sharded = other74.sharded;
  row_desc = other74.row_desc;
  node_id = other74.node_id;
  __isset = other74.__isset;
  return *this;
}
void TStepResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStepResult(";
  out << "serialized_rows=" << to_string(serialized_rows);
  out << ", " << "execution_finished=" << to_string(execution_finished);
  out << ", " << "merge_type=" << to_string(merge_type);
  out << ", " << "sharded=" << to_string(sharded);
  out << ", " << "row_desc=" << to_string(row_desc);
  out << ", " << "node_id=" << to_string(node_id);
  out << ")";
}


TRowSet::~TRowSet() noexcept {
}


void TRowSet::__set_row_desc(const TRowDescriptor& val) {
  this->row_desc = val;
}

void TRowSet::__set_rows(const std::vector<TRow> & val) {
  this->rows = val;
}

void TRowSet::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
}

void TRowSet::__set_is_columnar(const bool val) {
  this->is_columnar = val;
}
std::ostream& operator<<(std::ostream& out, const TRowSet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRowSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_desc.clear();
            uint32_t _size75;
            ::apache::thrift::protocol::TType _etype78;
            xfer += iprot->readListBegin(_etype78, _size75);
            this->row_desc.resize(_size75);
            uint32_t _i79;
            for (_i79 = 0; _i79 < _size75; ++_i79)
            {
              xfer += this->row_desc[_i79].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rows.clear();
            uint32_t _size80;
            ::apache::thrift::protocol::TType _etype83;
            xfer += iprot->readListBegin(_etype83, _size80);
            this->rows.resize(_size80);
            uint32_t _i84;
            for (_i84 = 0; _i84 < _size80; ++_i84)
            {
              xfer += this->rows[_i84].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size85;
            ::apache::thrift::protocol::TType _etype88;
            xfer += iprot->readListBegin(_etype88, _size85);
            this->columns.resize(_size85);
            uint32_t _i89;
            for (_i89 = 0; _i89 < _size85; ++_i89)
            {
              xfer += this->columns[_i89].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_columnar);
          this->__isset.is_columnar = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRowSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRowSet");

  xfer += oprot->writeFieldBegin("row_desc", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_desc.size()));
    std::vector<TColumnType> ::const_iterator _iter90;
    for (_iter90 = this->row_desc.begin(); _iter90 != this->row_desc.end(); ++_iter90)
    {
      xfer += (*_iter90).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rows.size()));
    std::vector<TRow> ::const_iterator _iter91;
    for (_iter91 = this->rows.begin(); _iter91 != this->rows.end(); ++_iter91)
    {
      xfer += (*_iter91).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumn> ::const_iterator _iter92;
    for (_iter92 = this->columns.begin(); _iter92 != this->columns.end(); ++_iter92)
    {
      xfer += (*_iter92).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_columnar", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_columnar);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRowSet &a, TRowSet &b) {
  using ::std::swap;
  swap(a.row_desc, b.row_desc);
  swap(a.rows, b.rows);
  swap(a.columns, b.columns);
  swap(a.is_columnar, b.is_columnar);
  swap(a.__isset, b.__isset);
}

TRowSet::TRowSet(const TRowSet& other93) {
  row_desc = other93.row_desc;
  rows = other93.rows;
  columns = other93.columns;
  is_columnar = other93.is_columnar;
  __isset = other93.__isset;
}
TRowSet& TRowSet::operator=(const TRowSet& other94) {
  row_desc = other94.row_desc;
  rows = other94.rows;
  columns = other94.columns;
  is_columnar = other94.is_columnar;
  __isset = other94.__isset;
  return *this;
}
void TRowSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRowSet(";
  out << "row_desc=" << to_string(row_desc);
  out << ", " << "rows=" << to_string(rows);
  out << ", " << "columns=" << to_string(columns);
  out << ", " << "is_columnar=" << to_string(is_columnar);
  out << ")";
}


TQueryResult::~TQueryResult() noexcept {
}


void TQueryResult::__set_row_set(const TRowSet& val) {
  this->row_set = val;
}

void TQueryResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TQueryResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}

void TQueryResult::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void TQueryResult::__set_debug(const std::string& val) {
  this->debug = val;
}

void TQueryResult::__set_success(const bool val) {
  this->success = val;
}

void TQueryResult::__set_query_type(const TQueryType::type val) {
  this->query_type = val;
}
std::ostream& operator<<(std::ostream& out, const TQueryResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TQueryResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_set.read(iprot);
          this->__isset.row_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          this->__isset.nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->debug);
          this->__isset.debug = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast95;
          xfer += iprot->readI32(ecast95);
          this->query_type = static_cast<TQueryType::type>(ecast95);
          this->__isset.query_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TQueryResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TQueryResult");

  xfer += oprot->writeFieldBegin("row_set", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->row_set.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("debug", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->debug);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("query_type", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(static_cast<int32_t>(this->query_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TQueryResult &a, TQueryResult &b) {
  using ::std::swap;
  swap(a.row_set, b.row_set);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.nonce, b.nonce);
  swap(a.debug, b.debug);
  swap(a.success, b.success);
  swap(a.query_type, b.query_type);
  swap(a.__isset, b.__isset);
}

TQueryResult::TQueryResult(const TQueryResult& other96) {
  row_set = other96.row_set;
  execution_time_ms = other96.execution_time_ms;
  total_time_ms = other96.total_time_ms;
  nonce = other96.nonce;
  debug = other96.debug;
  success = other96.success;
  query_type = other96.query_type;
  __isset = other96.__isset;
}
TQueryResult& TQueryResult::operator=(const TQueryResult& other97) {
  row_set = other97.row_set;
  execution_time_ms = other97.execution_time_ms;
  total_time_ms = other97.total_time_ms;
  nonce = other97.nonce;
  debug = other97.debug;
  success = other97.success;
  query_type = other97.query_type;
  __isset = other97.__isset;
  return *this;
}
void TQueryResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TQueryResult(";
  out << "row_set=" << to_string(row_set);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "debug=" << to_string(debug);
  out << ", " << "success=" << to_string(success);
  out << ", " << "query_type=" << to_string(query_type);
  out << ")";
}


TDataFrame::~TDataFrame() noexcept {
}


void TDataFrame::__set_sm_handle(const std::string& val) {
  this->sm_handle = val;
}

void TDataFrame::__set_sm_size(const int64_t val) {
  this->sm_size = val;
}

void TDataFrame::__set_df_handle(const std::string& val) {
  this->df_handle = val;
}

void TDataFrame::__set_df_size(const int64_t val) {
  this->df_size = val;
}

void TDataFrame::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TDataFrame::__set_arrow_conversion_time_ms(const int64_t val) {
  this->arrow_conversion_time_ms = val;
}

void TDataFrame::__set_df_buffer(const std::string& val) {
  this->df_buffer = val;
}
std::ostream& operator<<(std::ostream& out, const TDataFrame& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDataFrame::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->sm_handle);
          this->__isset.sm_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sm_size);
          this->__isset.sm_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->df_handle);
          this->__isset.df_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->df_size);
          this->__isset.df_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->arrow_conversion_time_ms);
          this->__isset.arrow_conversion_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->df_buffer);
          this->__isset.df_buffer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDataFrame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataFrame");

  xfer += oprot->writeFieldBegin("sm_handle", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->sm_handle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sm_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->sm_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("df_handle", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->df_handle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("df_size", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->df_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arrow_conversion_time_ms", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->arrow_conversion_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("df_buffer", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeBinary(this->df_buffer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataFrame &a, TDataFrame &b) {
  using ::std::swap;
  swap(a.sm_handle, b.sm_handle);
  swap(a.sm_size, b.sm_size);
  swap(a.df_handle, b.df_handle);
  swap(a.df_size, b.df_size);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.arrow_conversion_time_ms, b.arrow_conversion_time_ms);
  swap(a.df_buffer, b.df_buffer);
  swap(a.__isset, b.__isset);
}

TDataFrame::TDataFrame(const TDataFrame& other98) {
  sm_handle = other98.sm_handle;
  sm_size = other98.sm_size;
  df_handle = other98.df_handle;
  df_size = other98.df_size;
  execution_time_ms = other98.execution_time_ms;
  arrow_conversion_time_ms = other98.arrow_conversion_time_ms;
  df_buffer = other98.df_buffer;
  __isset = other98.__isset;
}
TDataFrame& TDataFrame::operator=(const TDataFrame& other99) {
  sm_handle = other99.sm_handle;
  sm_size = other99.sm_size;
  df_handle = other99.df_handle;
  df_size = other99.df_size;
  execution_time_ms = other99.execution_time_ms;
  arrow_conversion_time_ms = other99.arrow_conversion_time_ms;
  df_buffer = other99.df_buffer;
  __isset = other99.__isset;
  return *this;
}
void TDataFrame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataFrame(";
  out << "sm_handle=" << to_string(sm_handle);
  out << ", " << "sm_size=" << to_string(sm_size);
  out << ", " << "df_handle=" << to_string(df_handle);
  out << ", " << "df_size=" << to_string(df_size);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "arrow_conversion_time_ms=" << to_string(arrow_conversion_time_ms);
  out << ", " << "df_buffer=" << to_string(df_buffer);
  out << ")";
}


TDBInfo::~TDBInfo() noexcept {
}


void TDBInfo::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void TDBInfo::__set_db_owner(const std::string& val) {
  this->db_owner = val;
}

void TDBInfo::__set_immerse_metadata_json(const std::string& val) {
  this->immerse_metadata_json = val;
}
std::ostream& operator<<(std::ostream& out, const TDBInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDBInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_owner);
          this->__isset.db_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->immerse_metadata_json);
          this->__isset.immerse_metadata_json = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDBInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDBInfo");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_owner", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("immerse_metadata_json", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->immerse_metadata_json);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDBInfo &a, TDBInfo &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.db_owner, b.db_owner);
  swap(a.immerse_metadata_json, b.immerse_metadata_json);
  swap(a.__isset, b.__isset);
}

TDBInfo::TDBInfo(const TDBInfo& other100) {
  db_name = other100.db_name;
  db_owner = other100.db_owner;
  immerse_metadata_json = other100.immerse_metadata_json;
  __isset = other100.__isset;
}
TDBInfo& TDBInfo::operator=(const TDBInfo& other101) {
  db_name = other101.db_name;
  db_owner = other101.db_owner;
  immerse_metadata_json = other101.immerse_metadata_json;
  __isset = other101.__isset;
  return *this;
}
void TDBInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDBInfo(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "db_owner=" << to_string(db_owner);
  out << ", " << "immerse_metadata_json=" << to_string(immerse_metadata_json);
  out << ")";
}


TDBException::~TDBException() noexcept {
}


void TDBException::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}
std::ostream& operator<<(std::ostream& out, const TDBException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDBException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDBException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDBException");

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDBException &a, TDBException &b) {
  using ::std::swap;
  swap(a.error_msg, b.error_msg);
  swap(a.__isset, b.__isset);
}

TDBException::TDBException(const TDBException& other102) : TException() {
  error_msg = other102.error_msg;
  __isset = other102.__isset;
}
TDBException& TDBException::operator=(const TDBException& other103) {
  error_msg = other103.error_msg;
  __isset = other103.__isset;
  return *this;
}
void TDBException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDBException(";
  out << "error_msg=" << to_string(error_msg);
  out << ")";
}

const char* TDBException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TDBException";
  }
}


TCopyParams::~TCopyParams() noexcept {
}


void TCopyParams::__set_delimiter(const std::string& val) {
  this->delimiter = val;
}

void TCopyParams::__set_null_str(const std::string& val) {
  this->null_str = val;
}

void TCopyParams::__set_has_header(const TImportHeaderRow::type val) {
  this->has_header = val;
}

void TCopyParams::__set_quoted(const bool val) {
  this->quoted = val;
}

void TCopyParams::__set_quote(const std::string& val) {
  this->quote = val;
}

void TCopyParams::__set_escape(const std::string& val) {
  this->escape = val;
}

void TCopyParams::__set_line_delim(const std::string& val) {
  this->line_delim = val;
}

void TCopyParams::__set_array_delim(const std::string& val) {
  this->array_delim = val;
}

void TCopyParams::__set_array_begin(const std::string& val) {
  this->array_begin = val;
}

void TCopyParams::__set_array_end(const std::string& val) {
  this->array_end = val;
}

void TCopyParams::__set_threads(const int32_t val) {
  this->threads = val;
}

void TCopyParams::__set_source_type(const TSourceType::type val) {
  this->source_type = val;
}

void TCopyParams::__set_s3_access_key(const std::string& val) {
  this->s3_access_key = val;
}

void TCopyParams::__set_s3_secret_key(const std::string& val) {
  this->s3_secret_key = val;
}

void TCopyParams::__set_s3_region(const std::string& val) {
  this->s3_region = val;
}

void TCopyParams::__set_geo_coords_encoding(const  ::TEncodingType::type val) {
  this->geo_coords_encoding = val;
}

void TCopyParams::__set_geo_coords_comp_param(const int32_t val) {
  this->geo_coords_comp_param = val;
}

void TCopyParams::__set_geo_coords_type(const  ::TDatumType::type val) {
  this->geo_coords_type = val;
}

void TCopyParams::__set_geo_coords_srid(const int32_t val) {
  this->geo_coords_srid = val;
}

void TCopyParams::__set_sanitize_column_names(const bool val) {
  this->sanitize_column_names = val;
}

void TCopyParams::__set_geo_layer_name(const std::string& val) {
  this->geo_layer_name = val;
}

void TCopyParams::__set_s3_endpoint(const std::string& val) {
  this->s3_endpoint = val;
}

void TCopyParams::__set_geo_assign_render_groups(const bool val) {
  this->geo_assign_render_groups = val;
}

void TCopyParams::__set_geo_explode_collections(const bool val) {
  this->geo_explode_collections = val;
}

void TCopyParams::__set_source_srid(const int32_t val) {
  this->source_srid = val;
}

void TCopyParams::__set_s3_session_token(const std::string& val) {
  this->s3_session_token = val;
}

void TCopyParams::__set_raster_point_type(const TRasterPointType::type val) {
  this->raster_point_type = val;
}

void TCopyParams::__set_raster_import_bands(const std::string& val) {
  this->raster_import_bands = val;
}

void TCopyParams::__set_raster_scanlines_per_thread(const int32_t val) {
  this->raster_scanlines_per_thread = val;
}

void TCopyParams::__set_raster_point_transform(const TRasterPointTransform::type val) {
  this->raster_point_transform = val;
}

void TCopyParams::__set_raster_point_compute_angle(const bool val) {
  this->raster_point_compute_angle = val;
}

void TCopyParams::__set_raster_import_dimensions(const std::string& val) {
  this->raster_import_dimensions = val;
}

void TCopyParams::__set_odbc_dsn(const std::string& val) {
  this->odbc_dsn = val;
}

void TCopyParams::__set_odbc_connection_string(const std::string& val) {
  this->odbc_connection_string = val;
}

void TCopyParams::__set_odbc_sql_select(const std::string& val) {
  this->odbc_sql_select = val;
}

void TCopyParams::__set_odbc_sql_order_by(const std::string& val) {
  this->odbc_sql_order_by = val;
}

void TCopyParams::__set_odbc_username(const std::string& val) {
  this->odbc_username = val;
}

void TCopyParams::__set_odbc_password(const std::string& val) {
  this->odbc_password = val;
}

void TCopyParams::__set_odbc_credential_string(const std::string& val) {
  this->odbc_credential_string = val;
}

void TCopyParams::__set_add_metadata_columns(const std::string& val) {
  this->add_metadata_columns = val;
}

void TCopyParams::__set_trim_spaces(const bool val) {
  this->trim_spaces = val;
}

void TCopyParams::__set_geo_validate_geometry(const bool val) {
  this->geo_validate_geometry = val;
}

void TCopyParams::__set_raster_drop_if_all_null(const bool val) {
  this->raster_drop_if_all_null = val;
}

void TCopyParams::__set_bounding_box_clip(const std::string& val) {
  this->bounding_box_clip = val;
}
std::ostream& operator<<(std::ostream& out, const TCopyParams& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCopyParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->delimiter);
          this->__isset.delimiter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->null_str);
          this->__isset.null_str = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast104;
          xfer += iprot->readI32(ecast104);
          this->has_header = static_cast<TImportHeaderRow::type>(ecast104);
          this->__isset.has_header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->quoted);
          this->__isset.quoted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->quote);
          this->__isset.quote = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->escape);
          this->__isset.escape = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->line_delim);
          this->__isset.line_delim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->array_delim);
          this->__isset.array_delim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->array_begin);
          this->__isset.array_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->array_end);
          this->__isset.array_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->threads);
          this->__isset.threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast105;
          xfer += iprot->readI32(ecast105);
          this->source_type = static_cast<TSourceType::type>(ecast105);
          this->__isset.source_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_access_key);
          this->__isset.s3_access_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_secret_key);
          this->__isset.s3_secret_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_region);
          this->__isset.s3_region = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast106;
          xfer += iprot->readI32(ecast106);
          this->geo_coords_encoding = static_cast< ::TEncodingType::type>(ecast106);
          this->__isset.geo_coords_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->geo_coords_comp_param);
          this->__isset.geo_coords_comp_param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast107;
          xfer += iprot->readI32(ecast107);
          this->geo_coords_type = static_cast< ::TDatumType::type>(ecast107);
          this->__isset.geo_coords_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->geo_coords_srid);
          this->__isset.geo_coords_srid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sanitize_column_names);
          this->__isset.sanitize_column_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->geo_layer_name);
          this->__isset.geo_layer_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_endpoint);
          this->__isset.s3_endpoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->geo_assign_render_groups);
          this->__isset.geo_assign_render_groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->geo_explode_collections);
          this->__isset.geo_explode_collections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->source_srid);
          this->__isset.source_srid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_session_token);
          this->__isset.s3_session_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast108;
          xfer += iprot->readI32(ecast108);
          this->raster_point_type = static_cast<TRasterPointType::type>(ecast108);
          this->__isset.raster_point_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->raster_import_bands);
          this->__isset.raster_import_bands = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->raster_scanlines_per_thread);
          this->__isset.raster_scanlines_per_thread = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast109;
          xfer += iprot->readI32(ecast109);
          this->raster_point_transform = static_cast<TRasterPointTransform::type>(ecast109);
          this->__isset.raster_point_transform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->raster_point_compute_angle);
          this->__isset.raster_point_compute_angle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->raster_import_dimensions);
          this->__isset.raster_import_dimensions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->odbc_dsn);
          this->__isset.odbc_dsn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->odbc_connection_string);
          this->__isset.odbc_connection_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 35:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->odbc_sql_select);
          this->__isset.odbc_sql_select = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 36:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->odbc_sql_order_by);
          this->__isset.odbc_sql_order_by = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 37:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->odbc_username);
          this->__isset.odbc_username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 38:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->odbc_password);
          this->__isset.odbc_password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 39:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->odbc_credential_string);
          this->__isset.odbc_credential_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->add_metadata_columns);
          this->__isset.add_metadata_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->trim_spaces);
          this->__isset.trim_spaces = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 42:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->geo_validate_geometry);
          this->__isset.geo_validate_geometry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 43:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->raster_drop_if_all_null);
          this->__isset.raster_drop_if_all_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 44:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bounding_box_clip);
          this->__isset.bounding_box_clip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCopyParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCopyParams");

  xfer += oprot->writeFieldBegin("delimiter", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->delimiter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("null_str", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->null_str);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_header", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(static_cast<int32_t>(this->has_header));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quoted", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->quoted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quote", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->quote);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("escape", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->escape);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("line_delim", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->line_delim);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("array_delim", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->array_delim);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("array_begin", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->array_begin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("array_end", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->array_end);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("threads", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->threads);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("source_type", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(static_cast<int32_t>(this->source_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_access_key", ::apache::thrift::protocol::T_STRING, 13);
  xfer += oprot->writeString(this->s3_access_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_secret_key", ::apache::thrift::protocol::T_STRING, 14);
  xfer += oprot->writeString(this->s3_secret_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_region", ::apache::thrift::protocol::T_STRING, 15);
  xfer += oprot->writeString(this->s3_region);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_encoding", ::apache::thrift::protocol::T_I32, 16);
  xfer += oprot->writeI32(static_cast<int32_t>(this->geo_coords_encoding));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_comp_param", ::apache::thrift::protocol::T_I32, 17);
  xfer += oprot->writeI32(this->geo_coords_comp_param);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_type", ::apache::thrift::protocol::T_I32, 18);
  xfer += oprot->writeI32(static_cast<int32_t>(this->geo_coords_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_srid", ::apache::thrift::protocol::T_I32, 19);
  xfer += oprot->writeI32(this->geo_coords_srid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sanitize_column_names", ::apache::thrift::protocol::T_BOOL, 20);
  xfer += oprot->writeBool(this->sanitize_column_names);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_layer_name", ::apache::thrift::protocol::T_STRING, 21);
  xfer += oprot->writeString(this->geo_layer_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_endpoint", ::apache::thrift::protocol::T_STRING, 22);
  xfer += oprot->writeString(this->s3_endpoint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_assign_render_groups", ::apache::thrift::protocol::T_BOOL, 23);
  xfer += oprot->writeBool(this->geo_assign_render_groups);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_explode_collections", ::apache::thrift::protocol::T_BOOL, 24);
  xfer += oprot->writeBool(this->geo_explode_collections);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("source_srid", ::apache::thrift::protocol::T_I32, 25);
  xfer += oprot->writeI32(this->source_srid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_session_token", ::apache::thrift::protocol::T_STRING, 26);
  xfer += oprot->writeString(this->s3_session_token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raster_point_type", ::apache::thrift::protocol::T_I32, 27);
  xfer += oprot->writeI32(static_cast<int32_t>(this->raster_point_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raster_import_bands", ::apache::thrift::protocol::T_STRING, 28);
  xfer += oprot->writeString(this->raster_import_bands);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raster_scanlines_per_thread", ::apache::thrift::protocol::T_I32, 29);
  xfer += oprot->writeI32(this->raster_scanlines_per_thread);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raster_point_transform", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(static_cast<int32_t>(this->raster_point_transform));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raster_point_compute_angle", ::apache::thrift::protocol::T_BOOL, 31);
  xfer += oprot->writeBool(this->raster_point_compute_angle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raster_import_dimensions", ::apache::thrift::protocol::T_STRING, 32);
  xfer += oprot->writeString(this->raster_import_dimensions);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("odbc_dsn", ::apache::thrift::protocol::T_STRING, 33);
  xfer += oprot->writeString(this->odbc_dsn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("odbc_connection_string", ::apache::thrift::protocol::T_STRING, 34);
  xfer += oprot->writeString(this->odbc_connection_string);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("odbc_sql_select", ::apache::thrift::protocol::T_STRING, 35);
  xfer += oprot->writeString(this->odbc_sql_select);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("odbc_sql_order_by", ::apache::thrift::protocol::T_STRING, 36);
  xfer += oprot->writeString(this->odbc_sql_order_by);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("odbc_username", ::apache::thrift::protocol::T_STRING, 37);
  xfer += oprot->writeString(this->odbc_username);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("odbc_password", ::apache::thrift::protocol::T_STRING, 38);
  xfer += oprot->writeString(this->odbc_password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("odbc_credential_string", ::apache::thrift::protocol::T_STRING, 39);
  xfer += oprot->writeString(this->odbc_credential_string);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("add_metadata_columns", ::apache::thrift::protocol::T_STRING, 40);
  xfer += oprot->writeString(this->add_metadata_columns);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("trim_spaces", ::apache::thrift::protocol::T_BOOL, 41);
  xfer += oprot->writeBool(this->trim_spaces);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_validate_geometry", ::apache::thrift::protocol::T_BOOL, 42);
  xfer += oprot->writeBool(this->geo_validate_geometry);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raster_drop_if_all_null", ::apache::thrift::protocol::T_BOOL, 43);
  xfer += oprot->writeBool(this->raster_drop_if_all_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bounding_box_clip", ::apache::thrift::protocol::T_STRING, 44);
  xfer += oprot->writeString(this->bounding_box_clip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCopyParams &a, TCopyParams &b) {
  using ::std::swap;
  swap(a.delimiter, b.delimiter);
  swap(a.null_str, b.null_str);
  swap(a.has_header, b.has_header);
  swap(a.quoted, b.quoted);
  swap(a.quote, b.quote);
  swap(a.escape, b.escape);
  swap(a.line_delim, b.line_delim);
  swap(a.array_delim, b.array_delim);
  swap(a.array_begin, b.array_begin);
  swap(a.array_end, b.array_end);
  swap(a.threads, b.threads);
  swap(a.source_type, b.source_type);
  swap(a.s3_access_key, b.s3_access_key);
  swap(a.s3_secret_key, b.s3_secret_key);
  swap(a.s3_region, b.s3_region);
  swap(a.geo_coords_encoding, b.geo_coords_encoding);
  swap(a.geo_coords_comp_param, b.geo_coords_comp_param);
  swap(a.geo_coords_type, b.geo_coords_type);
  swap(a.geo_coords_srid, b.geo_coords_srid);
  swap(a.sanitize_column_names, b.sanitize_column_names);
  swap(a.geo_layer_name, b.geo_layer_name);
  swap(a.s3_endpoint, b.s3_endpoint);
  swap(a.geo_assign_render_groups, b.geo_assign_render_groups);
  swap(a.geo_explode_collections, b.geo_explode_collections);
  swap(a.source_srid, b.source_srid);
  swap(a.s3_session_token, b.s3_session_token);
  swap(a.raster_point_type, b.raster_point_type);
  swap(a.raster_import_bands, b.raster_import_bands);
  swap(a.raster_scanlines_per_thread, b.raster_scanlines_per_thread);
  swap(a.raster_point_transform, b.raster_point_transform);
  swap(a.raster_point_compute_angle, b.raster_point_compute_angle);
  swap(a.raster_import_dimensions, b.raster_import_dimensions);
  swap(a.odbc_dsn, b.odbc_dsn);
  swap(a.odbc_connection_string, b.odbc_connection_string);
  swap(a.odbc_sql_select, b.odbc_sql_select);
  swap(a.odbc_sql_order_by, b.odbc_sql_order_by);
  swap(a.odbc_username, b.odbc_username);
  swap(a.odbc_password, b.odbc_password);
  swap(a.odbc_credential_string, b.odbc_credential_string);
  swap(a.add_metadata_columns, b.add_metadata_columns);
  swap(a.trim_spaces, b.trim_spaces);
  swap(a.geo_validate_geometry, b.geo_validate_geometry);
  swap(a.raster_drop_if_all_null, b.raster_drop_if_all_null);
  swap(a.bounding_box_clip, b.bounding_box_clip);
  swap(a.__isset, b.__isset);
}

TCopyParams::TCopyParams(const TCopyParams& other110) {
  delimiter = other110.delimiter;
  null_str = other110.null_str;
  has_header = other110.has_header;
  quoted = other110.quoted;
  quote = other110.quote;
  escape = other110.escape;
  line_delim = other110.line_delim;
  array_delim = other110.array_delim;
  array_begin = other110.array_begin;
  array_end = other110.array_end;
  threads = other110.threads;
  source_type = other110.source_type;
  s3_access_key = other110.s3_access_key;
  s3_secret_key = other110.s3_secret_key;
  s3_region = other110.s3_region;
  geo_coords_encoding = other110.geo_coords_encoding;
  geo_coords_comp_param = other110.geo_coords_comp_param;
  geo_coords_type = other110.geo_coords_type;
  geo_coords_srid = other110.geo_coords_srid;
  sanitize_column_names = other110.sanitize_column_names;
  geo_layer_name = other110.geo_layer_name;
  s3_endpoint = other110.s3_endpoint;
  geo_assign_render_groups = other110.geo_assign_render_groups;
  geo_explode_collections = other110.geo_explode_collections;
  source_srid = other110.source_srid;
  s3_session_token = other110.s3_session_token;
  raster_point_type = other110.raster_point_type;
  raster_import_bands = other110.raster_import_bands;
  raster_scanlines_per_thread = other110.raster_scanlines_per_thread;
  raster_point_transform = other110.raster_point_transform;
  raster_point_compute_angle = other110.raster_point_compute_angle;
  raster_import_dimensions = other110.raster_import_dimensions;
  odbc_dsn = other110.odbc_dsn;
  odbc_connection_string = other110.odbc_connection_string;
  odbc_sql_select = other110.odbc_sql_select;
  odbc_sql_order_by = other110.odbc_sql_order_by;
  odbc_username = other110.odbc_username;
  odbc_password = other110.odbc_password;
  odbc_credential_string = other110.odbc_credential_string;
  add_metadata_columns = other110.add_metadata_columns;
  trim_spaces = other110.trim_spaces;
  geo_validate_geometry = other110.geo_validate_geometry;
  raster_drop_if_all_null = other110.raster_drop_if_all_null;
  bounding_box_clip = other110.bounding_box_clip;
  __isset = other110.__isset;
}
TCopyParams& TCopyParams::operator=(const TCopyParams& other111) {
  delimiter = other111.delimiter;
  null_str = other111.null_str;
  has_header = other111.has_header;
  quoted = other111.quoted;
  quote = other111.quote;
  escape = other111.escape;
  line_delim = other111.line_delim;
  array_delim = other111.array_delim;
  array_begin = other111.array_begin;
  array_end = other111.array_end;
  threads = other111.threads;
  source_type = other111.source_type;
  s3_access_key = other111.s3_access_key;
  s3_secret_key = other111.s3_secret_key;
  s3_region = other111.s3_region;
  geo_coords_encoding = other111.geo_coords_encoding;
  geo_coords_comp_param = other111.geo_coords_comp_param;
  geo_coords_type = other111.geo_coords_type;
  geo_coords_srid = other111.geo_coords_srid;
  sanitize_column_names = other111.sanitize_column_names;
  geo_layer_name = other111.geo_layer_name;
  s3_endpoint = other111.s3_endpoint;
  geo_assign_render_groups = other111.geo_assign_render_groups;
  geo_explode_collections = other111.geo_explode_collections;
  source_srid = other111.source_srid;
  s3_session_token = other111.s3_session_token;
  raster_point_type = other111.raster_point_type;
  raster_import_bands = other111.raster_import_bands;
  raster_scanlines_per_thread = other111.raster_scanlines_per_thread;
  raster_point_transform = other111.raster_point_transform;
  raster_point_compute_angle = other111.raster_point_compute_angle;
  raster_import_dimensions = other111.raster_import_dimensions;
  odbc_dsn = other111.odbc_dsn;
  odbc_connection_string = other111.odbc_connection_string;
  odbc_sql_select = other111.odbc_sql_select;
  odbc_sql_order_by = other111.odbc_sql_order_by;
  odbc_username = other111.odbc_username;
  odbc_password = other111.odbc_password;
  odbc_credential_string = other111.odbc_credential_string;
  add_metadata_columns = other111.add_metadata_columns;
  trim_spaces = other111.trim_spaces;
  geo_validate_geometry = other111.geo_validate_geometry;
  raster_drop_if_all_null = other111.raster_drop_if_all_null;
  bounding_box_clip = other111.bounding_box_clip;
  __isset = other111.__isset;
  return *this;
}
void TCopyParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCopyParams(";
  out << "delimiter=" << to_string(delimiter);
  out << ", " << "null_str=" << to_string(null_str);
  out << ", " << "has_header=" << to_string(has_header);
  out << ", " << "quoted=" << to_string(quoted);
  out << ", " << "quote=" << to_string(quote);
  out << ", " << "escape=" << to_string(escape);
  out << ", " << "line_delim=" << to_string(line_delim);
  out << ", " << "array_delim=" << to_string(array_delim);
  out << ", " << "array_begin=" << to_string(array_begin);
  out << ", " << "array_end=" << to_string(array_end);
  out << ", " << "threads=" << to_string(threads);
  out << ", " << "source_type=" << to_string(source_type);
  out << ", " << "s3_access_key=" << to_string(s3_access_key);
  out << ", " << "s3_secret_key=" << to_string(s3_secret_key);
  out << ", " << "s3_region=" << to_string(s3_region);
  out << ", " << "geo_coords_encoding=" << to_string(geo_coords_encoding);
  out << ", " << "geo_coords_comp_param=" << to_string(geo_coords_comp_param);
  out << ", " << "geo_coords_type=" << to_string(geo_coords_type);
  out << ", " << "geo_coords_srid=" << to_string(geo_coords_srid);
  out << ", " << "sanitize_column_names=" << to_string(sanitize_column_names);
  out << ", " << "geo_layer_name=" << to_string(geo_layer_name);
  out << ", " << "s3_endpoint=" << to_string(s3_endpoint);
  out << ", " << "geo_assign_render_groups=" << to_string(geo_assign_render_groups);
  out << ", " << "geo_explode_collections=" << to_string(geo_explode_collections);
  out << ", " << "source_srid=" << to_string(source_srid);
  out << ", " << "s3_session_token=" << to_string(s3_session_token);
  out << ", " << "raster_point_type=" << to_string(raster_point_type);
  out << ", " << "raster_import_bands=" << to_string(raster_import_bands);
  out << ", " << "raster_scanlines_per_thread=" << to_string(raster_scanlines_per_thread);
  out << ", " << "raster_point_transform=" << to_string(raster_point_transform);
  out << ", " << "raster_point_compute_angle=" << to_string(raster_point_compute_angle);
  out << ", " << "raster_import_dimensions=" << to_string(raster_import_dimensions);
  out << ", " << "odbc_dsn=" << to_string(odbc_dsn);
  out << ", " << "odbc_connection_string=" << to_string(odbc_connection_string);
  out << ", " << "odbc_sql_select=" << to_string(odbc_sql_select);
  out << ", " << "odbc_sql_order_by=" << to_string(odbc_sql_order_by);
  out << ", " << "odbc_username=" << to_string(odbc_username);
  out << ", " << "odbc_password=" << to_string(odbc_password);
  out << ", " << "odbc_credential_string=" << to_string(odbc_credential_string);
  out << ", " << "add_metadata_columns=" << to_string(add_metadata_columns);
  out << ", " << "trim_spaces=" << to_string(trim_spaces);
  out << ", " << "geo_validate_geometry=" << to_string(geo_validate_geometry);
  out << ", " << "raster_drop_if_all_null=" << to_string(raster_drop_if_all_null);
  out << ", " << "bounding_box_clip=" << to_string(bounding_box_clip);
  out << ")";
}


TCreateParams::~TCreateParams() noexcept {
}


void TCreateParams::__set_is_replicated(const bool val) {
  this->is_replicated = val;
}
std::ostream& operator<<(std::ostream& out, const TCreateParams& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCreateParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_replicated);
          this->__isset.is_replicated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCreateParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateParams");

  xfer += oprot->writeFieldBegin("is_replicated", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_replicated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCreateParams &a, TCreateParams &b) {
  using ::std::swap;
  swap(a.is_replicated, b.is_replicated);
  swap(a.__isset, b.__isset);
}

TCreateParams::TCreateParams(const TCreateParams& other112) noexcept {
  is_replicated = other112.is_replicated;
  __isset = other112.__isset;
}
TCreateParams& TCreateParams::operator=(const TCreateParams& other113) noexcept {
  is_replicated = other113.is_replicated;
  __isset = other113.__isset;
  return *this;
}
void TCreateParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCreateParams(";
  out << "is_replicated=" << to_string(is_replicated);
  out << ")";
}


TDetectResult::~TDetectResult() noexcept {
}


void TDetectResult::__set_row_set(const TRowSet& val) {
  this->row_set = val;
}

void TDetectResult::__set_copy_params(const TCopyParams& val) {
  this->copy_params = val;
}
std::ostream& operator<<(std::ostream& out, const TDetectResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDetectResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_set.read(iprot);
          this->__isset.row_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->copy_params.read(iprot);
          this->__isset.copy_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDetectResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDetectResult");

  xfer += oprot->writeFieldBegin("row_set", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->row_set.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("copy_params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->copy_params.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDetectResult &a, TDetectResult &b) {
  using ::std::swap;
  swap(a.row_set, b.row_set);
  swap(a.copy_params, b.copy_params);
  swap(a.__isset, b.__isset);
}

TDetectResult::TDetectResult(const TDetectResult& other114) {
  row_set = other114.row_set;
  copy_params = other114.copy_params;
  __isset = other114.__isset;
}
TDetectResult& TDetectResult::operator=(const TDetectResult& other115) {
  row_set = other115.row_set;
  copy_params = other115.copy_params;
  __isset = other115.__isset;
  return *this;
}
void TDetectResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDetectResult(";
  out << "row_set=" << to_string(row_set);
  out << ", " << "copy_params=" << to_string(copy_params);
  out << ")";
}


TImportStatus::~TImportStatus() noexcept {
}


void TImportStatus::__set_elapsed(const int64_t val) {
  this->elapsed = val;
}

void TImportStatus::__set_rows_completed(const int64_t val) {
  this->rows_completed = val;
}

void TImportStatus::__set_rows_estimated(const int64_t val) {
  this->rows_estimated = val;
}

void TImportStatus::__set_rows_rejected(const int64_t val) {
  this->rows_rejected = val;
}
std::ostream& operator<<(std::ostream& out, const TImportStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TImportStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->elapsed);
          this->__isset.elapsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_completed);
          this->__isset.rows_completed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_estimated);
          this->__isset.rows_estimated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_rejected);
          this->__isset.rows_rejected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TImportStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TImportStatus");

  xfer += oprot->writeFieldBegin("elapsed", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->elapsed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows_completed", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->rows_completed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows_estimated", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->rows_estimated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows_rejected", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->rows_rejected);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TImportStatus &a, TImportStatus &b) {
  using ::std::swap;
  swap(a.elapsed, b.elapsed);
  swap(a.rows_completed, b.rows_completed);
  swap(a.rows_estimated, b.rows_estimated);
  swap(a.rows_rejected, b.rows_rejected);
  swap(a.__isset, b.__isset);
}

TImportStatus::TImportStatus(const TImportStatus& other116) noexcept {
  elapsed = other116.elapsed;
  rows_completed = other116.rows_completed;
  rows_estimated = other116.rows_estimated;
  rows_rejected = other116.rows_rejected;
  __isset = other116.__isset;
}
TImportStatus& TImportStatus::operator=(const TImportStatus& other117) noexcept {
  elapsed = other117.elapsed;
  rows_completed = other117.rows_completed;
  rows_estimated = other117.rows_estimated;
  rows_rejected = other117.rows_rejected;
  __isset = other117.__isset;
  return *this;
}
void TImportStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TImportStatus(";
  out << "elapsed=" << to_string(elapsed);
  out << ", " << "rows_completed=" << to_string(rows_completed);
  out << ", " << "rows_estimated=" << to_string(rows_estimated);
  out << ", " << "rows_rejected=" << to_string(rows_rejected);
  out << ")";
}


TFrontendView::~TFrontendView() noexcept {
}


void TFrontendView::__set_view_name(const std::string& val) {
  this->view_name = val;
}

void TFrontendView::__set_view_state(const std::string& val) {
  this->view_state = val;
}

void TFrontendView::__set_image_hash(const std::string& val) {
  this->image_hash = val;
}

void TFrontendView::__set_update_time(const std::string& val) {
  this->update_time = val;
}

void TFrontendView::__set_view_metadata(const std::string& val) {
  this->view_metadata = val;
}
std::ostream& operator<<(std::ostream& out, const TFrontendView& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TFrontendView::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_name);
          this->__isset.view_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_state);
          this->__isset.view_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image_hash);
          this->__isset.image_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->update_time);
          this->__isset.update_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_metadata);
          this->__isset.view_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TFrontendView::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFrontendView");

  xfer += oprot->writeFieldBegin("view_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->view_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_state", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->view_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("image_hash", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->image_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_time", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->update_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_metadata", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->view_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFrontendView &a, TFrontendView &b) {
  using ::std::swap;
  swap(a.view_name, b.view_name);
  swap(a.view_state, b.view_state);
  swap(a.image_hash, b.image_hash);
  swap(a.update_time, b.update_time);
  swap(a.view_metadata, b.view_metadata);
  swap(a.__isset, b.__isset);
}

TFrontendView::TFrontendView(const TFrontendView& other118) {
  view_name = other118.view_name;
  view_state = other118.view_state;
  image_hash = other118.image_hash;
  update_time = other118.update_time;
  view_metadata = other118.view_metadata;
  __isset = other118.__isset;
}
TFrontendView& TFrontendView::operator=(const TFrontendView& other119) {
  view_name = other119.view_name;
  view_state = other119.view_state;
  image_hash = other119.image_hash;
  update_time = other119.update_time;
  view_metadata = other119.view_metadata;
  __isset = other119.__isset;
  return *this;
}
void TFrontendView::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFrontendView(";
  out << "view_name=" << to_string(view_name);
  out << ", " << "view_state=" << to_string(view_state);
  out << ", " << "image_hash=" << to_string(image_hash);
  out << ", " << "update_time=" << to_string(update_time);
  out << ", " << "view_metadata=" << to_string(view_metadata);
  out << ")";
}


TServerStatus::~TServerStatus() noexcept {
}


void TServerStatus::__set_read_only(const bool val) {
  this->read_only = val;
}

void TServerStatus::__set_version(const std::string& val) {
  this->version = val;
}

void TServerStatus::__set_rendering_enabled(const bool val) {
  this->rendering_enabled = val;
}

void TServerStatus::__set_start_time(const int64_t val) {
  this->start_time = val;
}

void TServerStatus::__set_edition(const std::string& val) {
  this->edition = val;
}

void TServerStatus::__set_host_name(const std::string& val) {
  this->host_name = val;
}

void TServerStatus::__set_poly_rendering_enabled(const bool val) {
  this->poly_rendering_enabled = val;
}

void TServerStatus::__set_role(const TRole::type val) {
  this->role = val;
}

void TServerStatus::__set_renderer_status_json(const std::string& val) {
  this->renderer_status_json = val;
}

void TServerStatus::__set_host_id(const std::string& val) {
  this->host_id = val;
}
std::ostream& operator<<(std::ostream& out, const TServerStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TServerStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->read_only);
          this->__isset.read_only = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rendering_enabled);
          this->__isset.rendering_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_time);
          this->__isset.start_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->edition);
          this->__isset.edition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->poly_rendering_enabled);
          this->__isset.poly_rendering_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast120;
          xfer += iprot->readI32(ecast120);
          this->role = static_cast<TRole::type>(ecast120);
          this->__isset.role = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->renderer_status_json);
          this->__isset.renderer_status_json = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_id);
          this->__isset.host_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TServerStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TServerStatus");

  xfer += oprot->writeFieldBegin("read_only", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->read_only);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rendering_enabled", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->rendering_enabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->start_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("edition", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->edition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->host_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("poly_rendering_enabled", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->poly_rendering_enabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("role", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(static_cast<int32_t>(this->role));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("renderer_status_json", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->renderer_status_json);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("host_id", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->host_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TServerStatus &a, TServerStatus &b) {
  using ::std::swap;
  swap(a.read_only, b.read_only);
  swap(a.version, b.version);
  swap(a.rendering_enabled, b.rendering_enabled);
  swap(a.start_time, b.start_time);
  swap(a.edition, b.edition);
  swap(a.host_name, b.host_name);
  swap(a.poly_rendering_enabled, b.poly_rendering_enabled);
  swap(a.role, b.role);
  swap(a.renderer_status_json, b.renderer_status_json);
  swap(a.host_id, b.host_id);
  swap(a.__isset, b.__isset);
}

TServerStatus::TServerStatus(const TServerStatus& other121) {
  read_only = other121.read_only;
  version = other121.version;
  rendering_enabled = other121.rendering_enabled;
  start_time = other121.start_time;
  edition = other121.edition;
  host_name = other121.host_name;
  poly_rendering_enabled = other121.poly_rendering_enabled;
  role = other121.role;
  renderer_status_json = other121.renderer_status_json;
  host_id = other121.host_id;
  __isset = other121.__isset;
}
TServerStatus& TServerStatus::operator=(const TServerStatus& other122) {
  read_only = other122.read_only;
  version = other122.version;
  rendering_enabled = other122.rendering_enabled;
  start_time = other122.start_time;
  edition = other122.edition;
  host_name = other122.host_name;
  poly_rendering_enabled = other122.poly_rendering_enabled;
  role = other122.role;
  renderer_status_json = other122.renderer_status_json;
  host_id = other122.host_id;
  __isset = other122.__isset;
  return *this;
}
void TServerStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TServerStatus(";
  out << "read_only=" << to_string(read_only);
  out << ", " << "version=" << to_string(version);
  out << ", " << "rendering_enabled=" << to_string(rendering_enabled);
  out << ", " << "start_time=" << to_string(start_time);
  out << ", " << "edition=" << to_string(edition);
  out << ", " << "host_name=" << to_string(host_name);
  out << ", " << "poly_rendering_enabled=" << to_string(poly_rendering_enabled);
  out << ", " << "role=" << to_string(role);
  out << ", " << "renderer_status_json=" << to_string(renderer_status_json);
  out << ", " << "host_id=" << to_string(host_id);
  out << ")";
}


TPixel::~TPixel() noexcept {
}


void TPixel::__set_x(const int64_t val) {
  this->x = val;
}

void TPixel::__set_y(const int64_t val) {
  this->y = val;
}
std::ostream& operator<<(std::ostream& out, const TPixel& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPixel::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPixel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPixel");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPixel &a, TPixel &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.__isset, b.__isset);
}

TPixel::TPixel(const TPixel& other123) noexcept {
  x = other123.x;
  y = other123.y;
  __isset = other123.__isset;
}
TPixel& TPixel::operator=(const TPixel& other124) noexcept {
  x = other124.x;
  y = other124.y;
  __isset = other124.__isset;
  return *this;
}
void TPixel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPixel(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ")";
}


TPixelTableRowResult::~TPixelTableRowResult() noexcept {
}


void TPixelTableRowResult::__set_pixel(const TPixel& val) {
  this->pixel = val;
}

void TPixelTableRowResult::__set_vega_table_name(const std::string& val) {
  this->vega_table_name = val;
}

void TPixelTableRowResult::__set_table_id(const std::vector<int64_t> & val) {
  this->table_id = val;
}

void TPixelTableRowResult::__set_row_id(const std::vector<int64_t> & val) {
  this->row_id = val;
}

void TPixelTableRowResult::__set_row_set(const TRowSet& val) {
  this->row_set = val;
}

void TPixelTableRowResult::__set_nonce(const std::string& val) {
  this->nonce = val;
}
std::ostream& operator<<(std::ostream& out, const TPixelTableRowResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPixelTableRowResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pixel.read(iprot);
          this->__isset.pixel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vega_table_name);
          this->__isset.vega_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->table_id.clear();
            uint32_t _size125;
            ::apache::thrift::protocol::TType _etype128;
            xfer += iprot->readListBegin(_etype128, _size125);
            this->table_id.resize(_size125);
            uint32_t _i129;
            for (_i129 = 0; _i129 < _size125; ++_i129)
            {
              xfer += iprot->readI64(this->table_id[_i129]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_id.clear();
            uint32_t _size130;
            ::apache::thrift::protocol::TType _etype133;
            xfer += iprot->readListBegin(_etype133, _size130);
            this->row_id.resize(_size130);
            uint32_t _i134;
            for (_i134 = 0; _i134 < _size130; ++_i134)
            {
              xfer += iprot->readI64(this->row_id[_i134]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_set.read(iprot);
          this->__isset.row_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          this->__isset.nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPixelTableRowResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPixelTableRowResult");

  xfer += oprot->writeFieldBegin("pixel", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pixel.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vega_table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->vega_table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->table_id.size()));
    std::vector<int64_t> ::const_iterator _iter135;
    for (_iter135 = this->table_id.begin(); _iter135 != this->table_id.end(); ++_iter135)
    {
      xfer += oprot->writeI64((*_iter135));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_id", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->row_id.size()));
    std::vector<int64_t> ::const_iterator _iter136;
    for (_iter136 = this->row_id.begin(); _iter136 != this->row_id.end(); ++_iter136)
    {
      xfer += oprot->writeI64((*_iter136));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_set", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->row_set.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPixelTableRowResult &a, TPixelTableRowResult &b) {
  using ::std::swap;
  swap(a.pixel, b.pixel);
  swap(a.vega_table_name, b.vega_table_name);
  swap(a.table_id, b.table_id);
  swap(a.row_id, b.row_id);
  swap(a.row_set, b.row_set);
  swap(a.nonce, b.nonce);
  swap(a.__isset, b.__isset);
}

TPixelTableRowResult::TPixelTableRowResult(const TPixelTableRowResult& other137) {
  pixel = other137.pixel;
  vega_table_name = other137.vega_table_name;
  table_id = other137.table_id;
  row_id = other137.row_id;
  row_set = other137.row_set;
  nonce = other137.nonce;
  __isset = other137.__isset;
}
TPixelTableRowResult& TPixelTableRowResult::operator=(const TPixelTableRowResult& other138) {
  pixel = other138.pixel;
  vega_table_name = other138.vega_table_name;
  table_id = other138.table_id;
  row_id = other138.row_id;
  row_set = other138.row_set;
  nonce = other138.nonce;
  __isset = other138.__isset;
  return *this;
}
void TPixelTableRowResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPixelTableRowResult(";
  out << "pixel=" << to_string(pixel);
  out << ", " << "vega_table_name=" << to_string(vega_table_name);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "row_id=" << to_string(row_id);
  out << ", " << "row_set=" << to_string(row_set);
  out << ", " << "nonce=" << to_string(nonce);
  out << ")";
}


TRenderResult::~TRenderResult() noexcept {
}


void TRenderResult::__set_image(const std::string& val) {
  this->image = val;
}

void TRenderResult::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void TRenderResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TRenderResult::__set_render_time_ms(const int64_t val) {
  this->render_time_ms = val;
}

void TRenderResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}

void TRenderResult::__set_vega_metadata(const std::string& val) {
  this->vega_metadata = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->image);
          this->__isset.image = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          this->__isset.nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->render_time_ms);
          this->__isset.render_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vega_metadata);
          this->__isset.vega_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderResult");

  xfer += oprot->writeFieldBegin("image", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->image);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_time_ms", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->render_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vega_metadata", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->vega_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderResult &a, TRenderResult &b) {
  using ::std::swap;
  swap(a.image, b.image);
  swap(a.nonce, b.nonce);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.render_time_ms, b.render_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.vega_metadata, b.vega_metadata);
  swap(a.__isset, b.__isset);
}

TRenderResult::TRenderResult(const TRenderResult& other139) {
  image = other139.image;
  nonce = other139.nonce;
  execution_time_ms = other139.execution_time_ms;
  render_time_ms = other139.render_time_ms;
  total_time_ms = other139.total_time_ms;
  vega_metadata = other139.vega_metadata;
  __isset = other139.__isset;
}
TRenderResult& TRenderResult::operator=(const TRenderResult& other140) {
  image = other140.image;
  nonce = other140.nonce;
  execution_time_ms = other140.execution_time_ms;
  render_time_ms = other140.render_time_ms;
  total_time_ms = other140.total_time_ms;
  vega_metadata = other140.vega_metadata;
  __isset = other140.__isset;
  return *this;
}
void TRenderResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderResult(";
  out << "image=" << to_string(image);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "render_time_ms=" << to_string(render_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ", " << "vega_metadata=" << to_string(vega_metadata);
  out << ")";
}


TGpuSpecification::~TGpuSpecification() noexcept {
}


void TGpuSpecification::__set_num_sm(const int32_t val) {
  this->num_sm = val;
}

void TGpuSpecification::__set_clock_frequency_kHz(const int64_t val) {
  this->clock_frequency_kHz = val;
}

void TGpuSpecification::__set_memory(const int64_t val) {
  this->memory = val;
}

void TGpuSpecification::__set_compute_capability_major(const int16_t val) {
  this->compute_capability_major = val;
}

void TGpuSpecification::__set_compute_capability_minor(const int16_t val) {
  this->compute_capability_minor = val;
}
std::ostream& operator<<(std::ostream& out, const TGpuSpecification& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGpuSpecification::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_sm);
          this->__isset.num_sm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->clock_frequency_kHz);
          this->__isset.clock_frequency_kHz = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->memory);
          this->__isset.memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->compute_capability_major);
          this->__isset.compute_capability_major = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->compute_capability_minor);
          this->__isset.compute_capability_minor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGpuSpecification::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGpuSpecification");

  xfer += oprot->writeFieldBegin("num_sm", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_sm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clock_frequency_kHz", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->clock_frequency_kHz);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("memory", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->memory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compute_capability_major", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->compute_capability_major);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compute_capability_minor", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->compute_capability_minor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGpuSpecification &a, TGpuSpecification &b) {
  using ::std::swap;
  swap(a.num_sm, b.num_sm);
  swap(a.clock_frequency_kHz, b.clock_frequency_kHz);
  swap(a.memory, b.memory);
  swap(a.compute_capability_major, b.compute_capability_major);
  swap(a.compute_capability_minor, b.compute_capability_minor);
  swap(a.__isset, b.__isset);
}

TGpuSpecification::TGpuSpecification(const TGpuSpecification& other141) noexcept {
  num_sm = other141.num_sm;
  clock_frequency_kHz = other141.clock_frequency_kHz;
  memory = other141.memory;
  compute_capability_major = other141.compute_capability_major;
  compute_capability_minor = other141.compute_capability_minor;
  __isset = other141.__isset;
}
TGpuSpecification& TGpuSpecification::operator=(const TGpuSpecification& other142) noexcept {
  num_sm = other142.num_sm;
  clock_frequency_kHz = other142.clock_frequency_kHz;
  memory = other142.memory;
  compute_capability_major = other142.compute_capability_major;
  compute_capability_minor = other142.compute_capability_minor;
  __isset = other142.__isset;
  return *this;
}
void TGpuSpecification::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGpuSpecification(";
  out << "num_sm=" << to_string(num_sm);
  out << ", " << "clock_frequency_kHz=" << to_string(clock_frequency_kHz);
  out << ", " << "memory=" << to_string(memory);
  out << ", " << "compute_capability_major=" << to_string(compute_capability_major);
  out << ", " << "compute_capability_minor=" << to_string(compute_capability_minor);
  out << ")";
}


THardwareInfo::~THardwareInfo() noexcept {
}


void THardwareInfo::__set_num_gpu_hw(const int16_t val) {
  this->num_gpu_hw = val;
}

void THardwareInfo::__set_num_cpu_hw(const int16_t val) {
  this->num_cpu_hw = val;
}

void THardwareInfo::__set_num_gpu_allocated(const int16_t val) {
  this->num_gpu_allocated = val;
}

void THardwareInfo::__set_start_gpu(const int16_t val) {
  this->start_gpu = val;
}

void THardwareInfo::__set_host_name(const std::string& val) {
  this->host_name = val;
}

void THardwareInfo::__set_gpu_info(const std::vector<TGpuSpecification> & val) {
  this->gpu_info = val;
}
std::ostream& operator<<(std::ostream& out, const THardwareInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t THardwareInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->num_gpu_hw);
          this->__isset.num_gpu_hw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->num_cpu_hw);
          this->__isset.num_cpu_hw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->num_gpu_allocated);
          this->__isset.num_gpu_allocated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->start_gpu);
          this->__isset.start_gpu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->gpu_info.clear();
            uint32_t _size143;
            ::apache::thrift::protocol::TType _etype146;
            xfer += iprot->readListBegin(_etype146, _size143);
            this->gpu_info.resize(_size143);
            uint32_t _i147;
            for (_i147 = 0; _i147 < _size143; ++_i147)
            {
              xfer += this->gpu_info[_i147].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.gpu_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t THardwareInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THardwareInfo");

  xfer += oprot->writeFieldBegin("num_gpu_hw", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->num_gpu_hw);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_cpu_hw", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->num_cpu_hw);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_gpu_allocated", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->num_gpu_allocated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_gpu", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->start_gpu);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->host_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gpu_info", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->gpu_info.size()));
    std::vector<TGpuSpecification> ::const_iterator _iter148;
    for (_iter148 = this->gpu_info.begin(); _iter148 != this->gpu_info.end(); ++_iter148)
    {
      xfer += (*_iter148).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THardwareInfo &a, THardwareInfo &b) {
  using ::std::swap;
  swap(a.num_gpu_hw, b.num_gpu_hw);
  swap(a.num_cpu_hw, b.num_cpu_hw);
  swap(a.num_gpu_allocated, b.num_gpu_allocated);
  swap(a.start_gpu, b.start_gpu);
  swap(a.host_name, b.host_name);
  swap(a.gpu_info, b.gpu_info);
  swap(a.__isset, b.__isset);
}

THardwareInfo::THardwareInfo(const THardwareInfo& other149) {
  num_gpu_hw = other149.num_gpu_hw;
  num_cpu_hw = other149.num_cpu_hw;
  num_gpu_allocated = other149.num_gpu_allocated;
  start_gpu = other149.start_gpu;
  host_name = other149.host_name;
  gpu_info = other149.gpu_info;
  __isset = other149.__isset;
}
THardwareInfo& THardwareInfo::operator=(const THardwareInfo& other150) {
  num_gpu_hw = other150.num_gpu_hw;
  num_cpu_hw = other150.num_cpu_hw;
  num_gpu_allocated = other150.num_gpu_allocated;
  start_gpu = other150.start_gpu;
  host_name = other150.host_name;
  gpu_info = other150.gpu_info;
  __isset = other150.__isset;
  return *this;
}
void THardwareInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THardwareInfo(";
  out << "num_gpu_hw=" << to_string(num_gpu_hw);
  out << ", " << "num_cpu_hw=" << to_string(num_cpu_hw);
  out << ", " << "num_gpu_allocated=" << to_string(num_gpu_allocated);
  out << ", " << "start_gpu=" << to_string(start_gpu);
  out << ", " << "host_name=" << to_string(host_name);
  out << ", " << "gpu_info=" << to_string(gpu_info);
  out << ")";
}


TClusterHardwareInfo::~TClusterHardwareInfo() noexcept {
}


void TClusterHardwareInfo::__set_hardware_info(const std::vector<THardwareInfo> & val) {
  this->hardware_info = val;
}
std::ostream& operator<<(std::ostream& out, const TClusterHardwareInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TClusterHardwareInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->hardware_info.clear();
            uint32_t _size151;
            ::apache::thrift::protocol::TType _etype154;
            xfer += iprot->readListBegin(_etype154, _size151);
            this->hardware_info.resize(_size151);
            uint32_t _i155;
            for (_i155 = 0; _i155 < _size151; ++_i155)
            {
              xfer += this->hardware_info[_i155].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.hardware_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TClusterHardwareInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TClusterHardwareInfo");

  xfer += oprot->writeFieldBegin("hardware_info", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->hardware_info.size()));
    std::vector<THardwareInfo> ::const_iterator _iter156;
    for (_iter156 = this->hardware_info.begin(); _iter156 != this->hardware_info.end(); ++_iter156)
    {
      xfer += (*_iter156).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TClusterHardwareInfo &a, TClusterHardwareInfo &b) {
  using ::std::swap;
  swap(a.hardware_info, b.hardware_info);
  swap(a.__isset, b.__isset);
}

TClusterHardwareInfo::TClusterHardwareInfo(const TClusterHardwareInfo& other157) {
  hardware_info = other157.hardware_info;
  __isset = other157.__isset;
}
TClusterHardwareInfo& TClusterHardwareInfo::operator=(const TClusterHardwareInfo& other158) {
  hardware_info = other158.hardware_info;
  __isset = other158.__isset;
  return *this;
}
void TClusterHardwareInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TClusterHardwareInfo(";
  out << "hardware_info=" << to_string(hardware_info);
  out << ")";
}


TMemoryData::~TMemoryData() noexcept {
}


void TMemoryData::__set_slab(const int64_t val) {
  this->slab = val;
}

void TMemoryData::__set_start_page(const int32_t val) {
  this->start_page = val;
}

void TMemoryData::__set_num_pages(const int64_t val) {
  this->num_pages = val;
}

void TMemoryData::__set_touch(const int32_t val) {
  this->touch = val;
}

void TMemoryData::__set_chunk_key(const std::vector<int64_t> & val) {
  this->chunk_key = val;
}

void TMemoryData::__set_buffer_epoch(const int32_t val) {
  this->buffer_epoch = val;
}

void TMemoryData::__set_is_free(const bool val) {
  this->is_free = val;
}
std::ostream& operator<<(std::ostream& out, const TMemoryData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMemoryData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->slab);
          this->__isset.slab = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->start_page);
          this->__isset.start_page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_pages);
          this->__isset.num_pages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->touch);
          this->__isset.touch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->chunk_key.clear();
            uint32_t _size159;
            ::apache::thrift::protocol::TType _etype162;
            xfer += iprot->readListBegin(_etype162, _size159);
            this->chunk_key.resize(_size159);
            uint32_t _i163;
            for (_i163 = 0; _i163 < _size159; ++_i163)
            {
              xfer += iprot->readI64(this->chunk_key[_i163]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.chunk_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->buffer_epoch);
          this->__isset.buffer_epoch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_free);
          this->__isset.is_free = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMemoryData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMemoryData");

  xfer += oprot->writeFieldBegin("slab", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->slab);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_page", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->start_page);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_pages", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->num_pages);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("touch", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->touch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("chunk_key", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->chunk_key.size()));
    std::vector<int64_t> ::const_iterator _iter164;
    for (_iter164 = this->chunk_key.begin(); _iter164 != this->chunk_key.end(); ++_iter164)
    {
      xfer += oprot->writeI64((*_iter164));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("buffer_epoch", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->buffer_epoch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_free", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->is_free);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMemoryData &a, TMemoryData &b) {
  using ::std::swap;
  swap(a.slab, b.slab);
  swap(a.start_page, b.start_page);
  swap(a.num_pages, b.num_pages);
  swap(a.touch, b.touch);
  swap(a.chunk_key, b.chunk_key);
  swap(a.buffer_epoch, b.buffer_epoch);
  swap(a.is_free, b.is_free);
  swap(a.__isset, b.__isset);
}

TMemoryData::TMemoryData(const TMemoryData& other165) {
  slab = other165.slab;
  start_page = other165.start_page;
  num_pages = other165.num_pages;
  touch = other165.touch;
  chunk_key = other165.chunk_key;
  buffer_epoch = other165.buffer_epoch;
  is_free = other165.is_free;
  __isset = other165.__isset;
}
TMemoryData& TMemoryData::operator=(const TMemoryData& other166) {
  slab = other166.slab;
  start_page = other166.start_page;
  num_pages = other166.num_pages;
  touch = other166.touch;
  chunk_key = other166.chunk_key;
  buffer_epoch = other166.buffer_epoch;
  is_free = other166.is_free;
  __isset = other166.__isset;
  return *this;
}
void TMemoryData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMemoryData(";
  out << "slab=" << to_string(slab);
  out << ", " << "start_page=" << to_string(start_page);
  out << ", " << "num_pages=" << to_string(num_pages);
  out << ", " << "touch=" << to_string(touch);
  out << ", " << "chunk_key=" << to_string(chunk_key);
  out << ", " << "buffer_epoch=" << to_string(buffer_epoch);
  out << ", " << "is_free=" << to_string(is_free);
  out << ")";
}


TNodeMemoryInfo::~TNodeMemoryInfo() noexcept {
}


void TNodeMemoryInfo::__set_host_name(const std::string& val) {
  this->host_name = val;
}

void TNodeMemoryInfo::__set_page_size(const int64_t val) {
  this->page_size = val;
}

void TNodeMemoryInfo::__set_max_num_pages(const int64_t val) {
  this->max_num_pages = val;
}

void TNodeMemoryInfo::__set_num_pages_allocated(const int64_t val) {
  this->num_pages_allocated = val;
}

void TNodeMemoryInfo::__set_is_allocation_capped(const bool val) {
  this->is_allocation_capped = val;
}

void TNodeMemoryInfo::__set_node_memory_data(const std::vector<TMemoryData> & val) {
  this->node_memory_data = val;
}
std::ostream& operator<<(std::ostream& out, const TNodeMemoryInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TNodeMemoryInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->page_size);
          this->__isset.page_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_num_pages);
          this->__isset.max_num_pages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_pages_allocated);
          this->__isset.num_pages_allocated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_allocation_capped);
          this->__isset.is_allocation_capped = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->node_memory_data.clear();
            uint32_t _size167;
            ::apache::thrift::protocol::TType _etype170;
            xfer += iprot->readListBegin(_etype170, _size167);
            this->node_memory_data.resize(_size167);
            uint32_t _i171;
            for (_i171 = 0; _i171 < _size167; ++_i171)
            {
              xfer += this->node_memory_data[_i171].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.node_memory_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TNodeMemoryInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TNodeMemoryInfo");

  xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("page_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->page_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_num_pages", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->max_num_pages);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_pages_allocated", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->num_pages_allocated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_allocation_capped", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_allocation_capped);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_memory_data", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->node_memory_data.size()));
    std::vector<TMemoryData> ::const_iterator _iter172;
    for (_iter172 = this->node_memory_data.begin(); _iter172 != this->node_memory_data.end(); ++_iter172)
    {
      xfer += (*_iter172).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TNodeMemoryInfo &a, TNodeMemoryInfo &b) {
  using ::std::swap;
  swap(a.host_name, b.host_name);
  swap(a.page_size, b.page_size);
  swap(a.max_num_pages, b.max_num_pages);
  swap(a.num_pages_allocated, b.num_pages_allocated);
  swap(a.is_allocation_capped, b.is_allocation_capped);
  swap(a.node_memory_data, b.node_memory_data);
  swap(a.__isset, b.__isset);
}

TNodeMemoryInfo::TNodeMemoryInfo(const TNodeMemoryInfo& other173) {
  host_name = other173.host_name;
  page_size = other173.page_size;
  max_num_pages = other173.max_num_pages;
  num_pages_allocated = other173.num_pages_allocated;
  is_allocation_capped = other173.is_allocation_capped;
  node_memory_data = other173.node_memory_data;
  __isset = other173.__isset;
}
TNodeMemoryInfo& TNodeMemoryInfo::operator=(const TNodeMemoryInfo& other174) {
  host_name = other174.host_name;
  page_size = other174.page_size;
  max_num_pages = other174.max_num_pages;
  num_pages_allocated = other174.num_pages_allocated;
  is_allocation_capped = other174.is_allocation_capped;
  node_memory_data = other174.node_memory_data;
  __isset = other174.__isset;
  return *this;
}
void TNodeMemoryInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TNodeMemoryInfo(";
  out << "host_name=" << to_string(host_name);
  out << ", " << "page_size=" << to_string(page_size);
  out << ", " << "max_num_pages=" << to_string(max_num_pages);
  out << ", " << "num_pages_allocated=" << to_string(num_pages_allocated);
  out << ", " << "is_allocation_capped=" << to_string(is_allocation_capped);
  out << ", " << "node_memory_data=" << to_string(node_memory_data);
  out << ")";
}


TTableMeta::~TTableMeta() noexcept {
}


void TTableMeta::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void TTableMeta::__set_num_cols(const int64_t val) {
  this->num_cols = val;
}

void TTableMeta::__set_is_view(const bool val) {
  this->is_view = val;
}

void TTableMeta::__set_is_replicated(const bool val) {
  this->is_replicated = val;
}

void TTableMeta::__set_shard_count(const int64_t val) {
  this->shard_count = val;
}

void TTableMeta::__set_max_rows(const int64_t val) {
  this->max_rows = val;
}

void TTableMeta::__set_table_id(const int64_t val) {
  this->table_id = val;
}

void TTableMeta::__set_max_table_id(const int64_t val) {
  this->max_table_id = val;
}

void TTableMeta::__set_col_types(const std::vector< ::TTypeInfo> & val) {
  this->col_types = val;
}

void TTableMeta::__set_col_names(const std::vector<std::string> & val) {
  this->col_names = val;
}
std::ostream& operator<<(std::ostream& out, const TTableMeta& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableMeta::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_cols);
          this->__isset.num_cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_view);
          this->__isset.is_view = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_replicated);
          this->__isset.is_replicated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->shard_count);
          this->__isset.shard_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_rows);
          this->__isset.max_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_table_id);
          this->__isset.max_table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->col_types.clear();
            uint32_t _size175;
            ::apache::thrift::protocol::TType _etype178;
            xfer += iprot->readListBegin(_etype178, _size175);
            this->col_types.resize(_size175);
            uint32_t _i179;
            for (_i179 = 0; _i179 < _size175; ++_i179)
            {
              xfer += this->col_types[_i179].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.col_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->col_names.clear();
            uint32_t _size180;
            ::apache::thrift::protocol::TType _etype183;
            xfer += iprot->readListBegin(_etype183, _size180);
            this->col_names.resize(_size180);
            uint32_t _i184;
            for (_i184 = 0; _i184 < _size180; ++_i184)
            {
              xfer += iprot->readString(this->col_names[_i184]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.col_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableMeta::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableMeta");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_cols", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->num_cols);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_view", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_view);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_replicated", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_replicated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shard_count", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->shard_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_rows", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->max_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_table_id", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->max_table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_types", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->col_types.size()));
    std::vector< ::TTypeInfo> ::const_iterator _iter185;
    for (_iter185 = this->col_types.begin(); _iter185 != this->col_types.end(); ++_iter185)
    {
      xfer += (*_iter185).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_names", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->col_names.size()));
    std::vector<std::string> ::const_iterator _iter186;
    for (_iter186 = this->col_names.begin(); _iter186 != this->col_names.end(); ++_iter186)
    {
      xfer += oprot->writeString((*_iter186));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableMeta &a, TTableMeta &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.num_cols, b.num_cols);
  swap(a.is_view, b.is_view);
  swap(a.is_replicated, b.is_replicated);
  swap(a.shard_count, b.shard_count);
  swap(a.max_rows, b.max_rows);
  swap(a.table_id, b.table_id);
  swap(a.max_table_id, b.max_table_id);
  swap(a.col_types, b.col_types);
  swap(a.col_names, b.col_names);
  swap(a.__isset, b.__isset);
}

TTableMeta::TTableMeta(const TTableMeta& other187) {
  table_name = other187.table_name;
  num_cols = other187.num_cols;
  is_view = other187.is_view;
  is_replicated = other187.is_replicated;
  shard_count = other187.shard_count;
  max_rows = other187.max_rows;
  table_id = other187.table_id;
  max_table_id = other187.max_table_id;
  col_types = other187.col_types;
  col_names = other187.col_names;
  __isset = other187.__isset;
}
TTableMeta& TTableMeta::operator=(const TTableMeta& other188) {
  table_name = other188.table_name;
  num_cols = other188.num_cols;
  is_view = other188.is_view;
  is_replicated = other188.is_replicated;
  shard_count = other188.shard_count;
  max_rows = other188.max_rows;
  table_id = other188.table_id;
  max_table_id = other188.max_table_id;
  col_types = other188.col_types;
  col_names = other188.col_names;
  __isset = other188.__isset;
  return *this;
}
void TTableMeta::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableMeta(";
  out << "table_name=" << to_string(table_name);
  out << ", " << "num_cols=" << to_string(num_cols);
  out << ", " << "is_view=" << to_string(is_view);
  out << ", " << "is_replicated=" << to_string(is_replicated);
  out << ", " << "shard_count=" << to_string(shard_count);
  out << ", " << "max_rows=" << to_string(max_rows);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "max_table_id=" << to_string(max_table_id);
  out << ", " << "col_types=" << to_string(col_types);
  out << ", " << "col_names=" << to_string(col_names);
  out << ")";
}


TTableRefreshInfo::~TTableRefreshInfo() noexcept {
}


void TTableRefreshInfo::__set_update_type(const TTableRefreshUpdateType::type val) {
  this->update_type = val;
}

void TTableRefreshInfo::__set_timing_type(const TTableRefreshTimingType::type val) {
  this->timing_type = val;
}

void TTableRefreshInfo::__set_start_date_time(const std::string& val) {
  this->start_date_time = val;
}

void TTableRefreshInfo::__set_interval_type(const TTableRefreshIntervalType::type val) {
  this->interval_type = val;
}

void TTableRefreshInfo::__set_interval_count(const int64_t val) {
  this->interval_count = val;
}

void TTableRefreshInfo::__set_last_refresh_time(const std::string& val) {
  this->last_refresh_time = val;
}

void TTableRefreshInfo::__set_next_refresh_time(const std::string& val) {
  this->next_refresh_time = val;
}
std::ostream& operator<<(std::ostream& out, const TTableRefreshInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableRefreshInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast189;
          xfer += iprot->readI32(ecast189);
          this->update_type = static_cast<TTableRefreshUpdateType::type>(ecast189);
          this->__isset.update_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast190;
          xfer += iprot->readI32(ecast190);
          this->timing_type = static_cast<TTableRefreshTimingType::type>(ecast190);
          this->__isset.timing_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_date_time);
          this->__isset.start_date_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast191;
          xfer += iprot->readI32(ecast191);
          this->interval_type = static_cast<TTableRefreshIntervalType::type>(ecast191);
          this->__isset.interval_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->interval_count);
          this->__isset.interval_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->last_refresh_time);
          this->__isset.last_refresh_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->next_refresh_time);
          this->__isset.next_refresh_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableRefreshInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableRefreshInfo");

  xfer += oprot->writeFieldBegin("update_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->update_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timing_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->timing_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_date_time", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->start_date_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("interval_type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(static_cast<int32_t>(this->interval_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("interval_count", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->interval_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_refresh_time", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->last_refresh_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("next_refresh_time", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->next_refresh_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableRefreshInfo &a, TTableRefreshInfo &b) {
  using ::std::swap;
  swap(a.update_type, b.update_type);
  swap(a.timing_type, b.timing_type);
  swap(a.start_date_time, b.start_date_time);
  swap(a.interval_type, b.interval_type);
  swap(a.interval_count, b.interval_count);
  swap(a.last_refresh_time, b.last_refresh_time);
  swap(a.next_refresh_time, b.next_refresh_time);
  swap(a.__isset, b.__isset);
}

TTableRefreshInfo::TTableRefreshInfo(const TTableRefreshInfo& other192) {
  update_type = other192.update_type;
  timing_type = other192.timing_type;
  start_date_time = other192.start_date_time;
  interval_type = other192.interval_type;
  interval_count = other192.interval_count;
  last_refresh_time = other192.last_refresh_time;
  next_refresh_time = other192.next_refresh_time;
  __isset = other192.__isset;
}
TTableRefreshInfo& TTableRefreshInfo::operator=(const TTableRefreshInfo& other193) {
  update_type = other193.update_type;
  timing_type = other193.timing_type;
  start_date_time = other193.start_date_time;
  interval_type = other193.interval_type;
  interval_count = other193.interval_count;
  last_refresh_time = other193.last_refresh_time;
  next_refresh_time = other193.next_refresh_time;
  __isset = other193.__isset;
  return *this;
}
void TTableRefreshInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableRefreshInfo(";
  out << "update_type=" << to_string(update_type);
  out << ", " << "timing_type=" << to_string(timing_type);
  out << ", " << "start_date_time=" << to_string(start_date_time);
  out << ", " << "interval_type=" << to_string(interval_type);
  out << ", " << "interval_count=" << to_string(interval_count);
  out << ", " << "last_refresh_time=" << to_string(last_refresh_time);
  out << ", " << "next_refresh_time=" << to_string(next_refresh_time);
  out << ")";
}


TTableDetails::~TTableDetails() noexcept {
}


void TTableDetails::__set_row_desc(const TRowDescriptor& val) {
  this->row_desc = val;
}

void TTableDetails::__set_fragment_size(const int64_t val) {
  this->fragment_size = val;
}

void TTableDetails::__set_page_size(const int64_t val) {
  this->page_size = val;
}

void TTableDetails::__set_max_rows(const int64_t val) {
  this->max_rows = val;
}

void TTableDetails::__set_view_sql(const std::string& val) {
  this->view_sql = val;
}

void TTableDetails::__set_shard_count(const int64_t val) {
  this->shard_count = val;
}

void TTableDetails::__set_key_metainfo(const std::string& val) {
  this->key_metainfo = val;
}

void TTableDetails::__set_is_temporary(const bool val) {
  this->is_temporary = val;
}

void TTableDetails::__set_partition_detail(const TPartitionDetail::type val) {
  this->partition_detail = val;
}

void TTableDetails::__set_table_type(const TTableType::type val) {
  this->table_type = val;
}

void TTableDetails::__set_refresh_info(const TTableRefreshInfo& val) {
  this->refresh_info = val;
}

void TTableDetails::__set_sharded_column_name(const std::string& val) {
  this->sharded_column_name = val;
}

void TTableDetails::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}
std::ostream& operator<<(std::ostream& out, const TTableDetails& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableDetails::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_desc.clear();
            uint32_t _size194;
            ::apache::thrift::protocol::TType _etype197;
            xfer += iprot->readListBegin(_etype197, _size194);
            this->row_desc.resize(_size194);
            uint32_t _i198;
            for (_i198 = 0; _i198 < _size194; ++_i198)
            {
              xfer += this->row_desc[_i198].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fragment_size);
          this->__isset.fragment_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->page_size);
          this->__isset.page_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_rows);
          this->__isset.max_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_sql);
          this->__isset.view_sql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->shard_count);
          this->__isset.shard_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key_metainfo);
          this->__isset.key_metainfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_temporary);
          this->__isset.is_temporary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast199;
          xfer += iprot->readI32(ecast199);
          this->partition_detail = static_cast<TPartitionDetail::type>(ecast199);
          this->__isset.partition_detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast200;
          xfer += iprot->readI32(ecast200);
          this->table_type = static_cast<TTableType::type>(ecast200);
          this->__isset.table_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->refresh_info.read(iprot);
          this->__isset.refresh_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sharded_column_name);
          this->__isset.sharded_column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableDetails::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableDetails");

  xfer += oprot->writeFieldBegin("row_desc", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_desc.size()));
    std::vector<TColumnType> ::const_iterator _iter201;
    for (_iter201 = this->row_desc.begin(); _iter201 != this->row_desc.end(); ++_iter201)
    {
      xfer += (*_iter201).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fragment_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->fragment_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("page_size", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->page_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_rows", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->max_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_sql", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->view_sql);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shard_count", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->shard_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_metainfo", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->key_metainfo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_temporary", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->is_temporary);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_detail", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(static_cast<int32_t>(this->partition_detail));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_type", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(static_cast<int32_t>(this->table_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("refresh_info", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->refresh_info.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sharded_column_name", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->sharded_column_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableDetails &a, TTableDetails &b) {
  using ::std::swap;
  swap(a.row_desc, b.row_desc);
  swap(a.fragment_size, b.fragment_size);
  swap(a.page_size, b.page_size);
  swap(a.max_rows, b.max_rows);
  swap(a.view_sql, b.view_sql);
  swap(a.shard_count, b.shard_count);
  swap(a.key_metainfo, b.key_metainfo);
  swap(a.is_temporary, b.is_temporary);
  swap(a.partition_detail, b.partition_detail);
  swap(a.table_type, b.table_type);
  swap(a.refresh_info, b.refresh_info);
  swap(a.sharded_column_name, b.sharded_column_name);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

TTableDetails::TTableDetails(const TTableDetails& other202) {
  row_desc = other202.row_desc;
  fragment_size = other202.fragment_size;
  page_size = other202.page_size;
  max_rows = other202.max_rows;
  view_sql = other202.view_sql;
  shard_count = other202.shard_count;
  key_metainfo = other202.key_metainfo;
  is_temporary = other202.is_temporary;
  partition_detail = other202.partition_detail;
  table_type = other202.table_type;
  refresh_info = other202.refresh_info;
  sharded_column_name = other202.sharded_column_name;
  comment = other202.comment;
  __isset = other202.__isset;
}
TTableDetails& TTableDetails::operator=(const TTableDetails& other203) {
  row_desc = other203.row_desc;
  fragment_size = other203.fragment_size;
  page_size = other203.page_size;
  max_rows = other203.max_rows;
  view_sql = other203.view_sql;
  shard_count = other203.shard_count;
  key_metainfo = other203.key_metainfo;
  is_temporary = other203.is_temporary;
  partition_detail = other203.partition_detail;
  table_type = other203.table_type;
  refresh_info = other203.refresh_info;
  sharded_column_name = other203.sharded_column_name;
  comment = other203.comment;
  __isset = other203.__isset;
  return *this;
}
void TTableDetails::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableDetails(";
  out << "row_desc=" << to_string(row_desc);
  out << ", " << "fragment_size=" << to_string(fragment_size);
  out << ", " << "page_size=" << to_string(page_size);
  out << ", " << "max_rows=" << to_string(max_rows);
  out << ", " << "view_sql=" << to_string(view_sql);
  out << ", " << "shard_count=" << to_string(shard_count);
  out << ", " << "key_metainfo=" << to_string(key_metainfo);
  out << ", " << "is_temporary=" << to_string(is_temporary);
  out << ", " << "partition_detail=" << to_string(partition_detail);
  out << ", " << "table_type=" << to_string(table_type);
  out << ", " << "refresh_info=" << to_string(refresh_info);
  out << ", " << "sharded_column_name=" << to_string(sharded_column_name);
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ")";
}


TColumnRange::~TColumnRange() noexcept {
}


void TColumnRange::__set_type(const TExpressionRangeType::type val) {
  this->type = val;
}

void TColumnRange::__set_col_id(const int32_t val) {
  this->col_id = val;
}

void TColumnRange::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TColumnRange::__set_has_nulls(const bool val) {
  this->has_nulls = val;
}

void TColumnRange::__set_int_min(const int64_t val) {
  this->int_min = val;
}

void TColumnRange::__set_int_max(const int64_t val) {
  this->int_max = val;
}

void TColumnRange::__set_bucket(const int64_t val) {
  this->bucket = val;
}

void TColumnRange::__set_fp_min(const double val) {
  this->fp_min = val;
}

void TColumnRange::__set_fp_max(const double val) {
  this->fp_max = val;
}

void TColumnRange::__set_db_id(const int32_t val) {
  this->db_id = val;
}
std::ostream& operator<<(std::ostream& out, const TColumnRange& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast204;
          xfer += iprot->readI32(ecast204);
          this->type = static_cast<TExpressionRangeType::type>(ecast204);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->col_id);
          this->__isset.col_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_nulls);
          this->__isset.has_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_min);
          this->__isset.int_min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_max);
          this->__isset.int_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bucket);
          this->__isset.bucket = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fp_min);
          this->__isset.fp_min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fp_max);
          this->__isset.fp_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->db_id);
          this->__isset.db_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnRange");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->col_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_nulls", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->has_nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("int_min", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->int_min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("int_max", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->int_max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bucket", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->bucket);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fp_min", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->fp_min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fp_max", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->fp_max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->db_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnRange &a, TColumnRange &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.col_id, b.col_id);
  swap(a.table_id, b.table_id);
  swap(a.has_nulls, b.has_nulls);
  swap(a.int_min, b.int_min);
  swap(a.int_max, b.int_max);
  swap(a.bucket, b.bucket);
  swap(a.fp_min, b.fp_min);
  swap(a.fp_max, b.fp_max);
  swap(a.db_id, b.db_id);
  swap(a.__isset, b.__isset);
}

TColumnRange::TColumnRange(const TColumnRange& other205) noexcept {
  type = other205.type;
  col_id = other205.col_id;
  table_id = other205.table_id;
  has_nulls = other205.has_nulls;
  int_min = other205.int_min;
  int_max = other205.int_max;
  bucket = other205.bucket;
  fp_min = other205.fp_min;
  fp_max = other205.fp_max;
  db_id = other205.db_id;
  __isset = other205.__isset;
}
TColumnRange& TColumnRange::operator=(const TColumnRange& other206) noexcept {
  type = other206.type;
  col_id = other206.col_id;
  table_id = other206.table_id;
  has_nulls = other206.has_nulls;
  int_min = other206.int_min;
  int_max = other206.int_max;
  bucket = other206.bucket;
  fp_min = other206.fp_min;
  fp_max = other206.fp_max;
  db_id = other206.db_id;
  __isset = other206.__isset;
  return *this;
}
void TColumnRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnRange(";
  out << "type=" << to_string(type);
  out << ", " << "col_id=" << to_string(col_id);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "has_nulls=" << to_string(has_nulls);
  out << ", " << "int_min=" << to_string(int_min);
  out << ", " << "int_max=" << to_string(int_max);
  out << ", " << "bucket=" << to_string(bucket);
  out << ", " << "fp_min=" << to_string(fp_min);
  out << ", " << "fp_max=" << to_string(fp_max);
  out << ", " << "db_id=" << to_string(db_id);
  out << ")";
}


TDictionaryGeneration::~TDictionaryGeneration() noexcept {
}


void TDictionaryGeneration::__set_dict_id(const int32_t val) {
  this->dict_id = val;
}

void TDictionaryGeneration::__set_entry_count(const int64_t val) {
  this->entry_count = val;
}

void TDictionaryGeneration::__set_db_id(const int32_t val) {
  this->db_id = val;
}
std::ostream& operator<<(std::ostream& out, const TDictionaryGeneration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDictionaryGeneration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dict_id);
          this->__isset.dict_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->entry_count);
          this->__isset.entry_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->db_id);
          this->__isset.db_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDictionaryGeneration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDictionaryGeneration");

  xfer += oprot->writeFieldBegin("dict_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->dict_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entry_count", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->entry_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->db_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDictionaryGeneration &a, TDictionaryGeneration &b) {
  using ::std::swap;
  swap(a.dict_id, b.dict_id);
  swap(a.entry_count, b.entry_count);
  swap(a.db_id, b.db_id);
  swap(a.__isset, b.__isset);
}

TDictionaryGeneration::TDictionaryGeneration(const TDictionaryGeneration& other207) noexcept {
  dict_id = other207.dict_id;
  entry_count = other207.entry_count;
  db_id = other207.db_id;
  __isset = other207.__isset;
}
TDictionaryGeneration& TDictionaryGeneration::operator=(const TDictionaryGeneration& other208) noexcept {
  dict_id = other208.dict_id;
  entry_count = other208.entry_count;
  db_id = other208.db_id;
  __isset = other208.__isset;
  return *this;
}
void TDictionaryGeneration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDictionaryGeneration(";
  out << "dict_id=" << to_string(dict_id);
  out << ", " << "entry_count=" << to_string(entry_count);
  out << ", " << "db_id=" << to_string(db_id);
  out << ")";
}


TTableGeneration::~TTableGeneration() noexcept {
}


void TTableGeneration::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TTableGeneration::__set_tuple_count(const int64_t val) {
  this->tuple_count = val;
}

void TTableGeneration::__set_start_rowid(const int64_t val) {
  this->start_rowid = val;
}

void TTableGeneration::__set_db_id(const int32_t val) {
  this->db_id = val;
}
std::ostream& operator<<(std::ostream& out, const TTableGeneration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableGeneration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tuple_count);
          this->__isset.tuple_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_rowid);
          this->__isset.start_rowid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->db_id);
          this->__isset.db_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableGeneration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableGeneration");

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tuple_count", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->tuple_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_rowid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->start_rowid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_id", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->db_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableGeneration &a, TTableGeneration &b) {
  using ::std::swap;
  swap(a.table_id, b.table_id);
  swap(a.tuple_count, b.tuple_count);
  swap(a.start_rowid, b.start_rowid);
  swap(a.db_id, b.db_id);
  swap(a.__isset, b.__isset);
}

TTableGeneration::TTableGeneration(const TTableGeneration& other209) noexcept {
  table_id = other209.table_id;
  tuple_count = other209.tuple_count;
  start_rowid = other209.start_rowid;
  db_id = other209.db_id;
  __isset = other209.__isset;
}
TTableGeneration& TTableGeneration::operator=(const TTableGeneration& other210) noexcept {
  table_id = other210.table_id;
  tuple_count = other210.tuple_count;
  start_rowid = other210.start_rowid;
  db_id = other210.db_id;
  __isset = other210.__isset;
  return *this;
}
void TTableGeneration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableGeneration(";
  out << "table_id=" << to_string(table_id);
  out << ", " << "tuple_count=" << to_string(tuple_count);
  out << ", " << "start_rowid=" << to_string(start_rowid);
  out << ", " << "db_id=" << to_string(db_id);
  out << ")";
}


TTableCacheStatus::~TTableCacheStatus() noexcept {
}


void TTableCacheStatus::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TTableCacheStatus::__set_db_id(const int32_t val) {
  this->db_id = val;
}

void TTableCacheStatus::__set_is_cached_on_disk(const bool val) {
  this->is_cached_on_disk = val;
}
std::ostream& operator<<(std::ostream& out, const TTableCacheStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableCacheStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->db_id);
          this->__isset.db_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_cached_on_disk);
          this->__isset.is_cached_on_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableCacheStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableCacheStatus");

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->db_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_cached_on_disk", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_cached_on_disk);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableCacheStatus &a, TTableCacheStatus &b) {
  using ::std::swap;
  swap(a.table_id, b.table_id);
  swap(a.db_id, b.db_id);
  swap(a.is_cached_on_disk, b.is_cached_on_disk);
  swap(a.__isset, b.__isset);
}

TTableCacheStatus::TTableCacheStatus(const TTableCacheStatus& other211) noexcept {
  table_id = other211.table_id;
  db_id = other211.db_id;
  is_cached_on_disk = other211.is_cached_on_disk;
  __isset = other211.__isset;
}
TTableCacheStatus& TTableCacheStatus::operator=(const TTableCacheStatus& other212) noexcept {
  table_id = other212.table_id;
  db_id = other212.db_id;
  is_cached_on_disk = other212.is_cached_on_disk;
  __isset = other212.__isset;
  return *this;
}
void TTableCacheStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableCacheStatus(";
  out << "table_id=" << to_string(table_id);
  out << ", " << "db_id=" << to_string(db_id);
  out << ", " << "is_cached_on_disk=" << to_string(is_cached_on_disk);
  out << ")";
}


TPendingQuery::~TPendingQuery() noexcept {
}


void TPendingQuery::__set_id(const TQueryId val) {
  this->id = val;
}

void TPendingQuery::__set_column_ranges(const std::vector<TColumnRange> & val) {
  this->column_ranges = val;
}

void TPendingQuery::__set_dictionary_generations(const std::vector<TDictionaryGeneration> & val) {
  this->dictionary_generations = val;
}

void TPendingQuery::__set_table_generations(const std::vector<TTableGeneration> & val) {
  this->table_generations = val;
}

void TPendingQuery::__set_parent_session_id(const TSessionId& val) {
  this->parent_session_id = val;
}

void TPendingQuery::__set_table_cache_status(const std::vector<TTableCacheStatus> & val) {
  this->table_cache_status = val;
}
std::ostream& operator<<(std::ostream& out, const TPendingQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPendingQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_ranges.clear();
            uint32_t _size213;
            ::apache::thrift::protocol::TType _etype216;
            xfer += iprot->readListBegin(_etype216, _size213);
            this->column_ranges.resize(_size213);
            uint32_t _i217;
            for (_i217 = 0; _i217 < _size213; ++_i217)
            {
              xfer += this->column_ranges[_i217].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dictionary_generations.clear();
            uint32_t _size218;
            ::apache::thrift::protocol::TType _etype221;
            xfer += iprot->readListBegin(_etype221, _size218);
            this->dictionary_generations.resize(_size218);
            uint32_t _i222;
            for (_i222 = 0; _i222 < _size218; ++_i222)
            {
              xfer += this->dictionary_generations[_i222].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dictionary_generations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->table_generations.clear();
            uint32_t _size223;
            ::apache::thrift::protocol::TType _etype226;
            xfer += iprot->readListBegin(_etype226, _size223);
            this->table_generations.resize(_size223);
            uint32_t _i227;
            for (_i227 = 0; _i227 < _size223; ++_i227)
            {
              xfer += this->table_generations[_i227].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.table_generations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parent_session_id);
          this->__isset.parent_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->table_cache_status.clear();
            uint32_t _size228;
            ::apache::thrift::protocol::TType _etype231;
            xfer += iprot->readListBegin(_etype231, _size228);
            this->table_cache_status.resize(_size228);
            uint32_t _i232;
            for (_i232 = 0; _i232 < _size228; ++_i232)
            {
              xfer += this->table_cache_status[_i232].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.table_cache_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPendingQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPendingQuery");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_ranges", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_ranges.size()));
    std::vector<TColumnRange> ::const_iterator _iter233;
    for (_iter233 = this->column_ranges.begin(); _iter233 != this->column_ranges.end(); ++_iter233)
    {
      xfer += (*_iter233).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dictionary_generations", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dictionary_generations.size()));
    std::vector<TDictionaryGeneration> ::const_iterator _iter234;
    for (_iter234 = this->dictionary_generations.begin(); _iter234 != this->dictionary_generations.end(); ++_iter234)
    {
      xfer += (*_iter234).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_generations", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->table_generations.size()));
    std::vector<TTableGeneration> ::const_iterator _iter235;
    for (_iter235 = this->table_generations.begin(); _iter235 != this->table_generations.end(); ++_iter235)
    {
      xfer += (*_iter235).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parent_session_id", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->parent_session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_cache_status", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->table_cache_status.size()));
    std::vector<TTableCacheStatus> ::const_iterator _iter236;
    for (_iter236 = this->table_cache_status.begin(); _iter236 != this->table_cache_status.end(); ++_iter236)
    {
      xfer += (*_iter236).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPendingQuery &a, TPendingQuery &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.column_ranges, b.column_ranges);
  swap(a.dictionary_generations, b.dictionary_generations);
  swap(a.table_generations, b.table_generations);
  swap(a.parent_session_id, b.parent_session_id);
  swap(a.table_cache_status, b.table_cache_status);
  swap(a.__isset, b.__isset);
}

TPendingQuery::TPendingQuery(const TPendingQuery& other237) {
  id = other237.id;
  column_ranges = other237.column_ranges;
  dictionary_generations = other237.dictionary_generations;
  table_generations = other237.table_generations;
  parent_session_id = other237.parent_session_id;
  table_cache_status = other237.table_cache_status;
  __isset = other237.__isset;
}
TPendingQuery& TPendingQuery::operator=(const TPendingQuery& other238) {
  id = other238.id;
  column_ranges = other238.column_ranges;
  dictionary_generations = other238.dictionary_generations;
  table_generations = other238.table_generations;
  parent_session_id = other238.parent_session_id;
  table_cache_status = other238.table_cache_status;
  __isset = other238.__isset;
  return *this;
}
void TPendingQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPendingQuery(";
  out << "id=" << to_string(id);
  out << ", " << "column_ranges=" << to_string(column_ranges);
  out << ", " << "dictionary_generations=" << to_string(dictionary_generations);
  out << ", " << "table_generations=" << to_string(table_generations);
  out << ", " << "parent_session_id=" << to_string(parent_session_id);
  out << ", " << "table_cache_status=" << to_string(table_cache_status);
  out << ")";
}


TVarLen::~TVarLen() noexcept {
}


void TVarLen::__set_payload(const std::string& val) {
  this->payload = val;
}

void TVarLen::__set_is_null(const bool val) {
  this->is_null = val;
}
std::ostream& operator<<(std::ostream& out, const TVarLen& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TVarLen::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->payload);
          this->__isset.payload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          this->__isset.is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TVarLen::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TVarLen");

  xfer += oprot->writeFieldBegin("payload", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->payload);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TVarLen &a, TVarLen &b) {
  using ::std::swap;
  swap(a.payload, b.payload);
  swap(a.is_null, b.is_null);
  swap(a.__isset, b.__isset);
}

TVarLen::TVarLen(const TVarLen& other239) {
  payload = other239.payload;
  is_null = other239.is_null;
  __isset = other239.__isset;
}
TVarLen& TVarLen::operator=(const TVarLen& other240) {
  payload = other240.payload;
  is_null = other240.is_null;
  __isset = other240.__isset;
  return *this;
}
void TVarLen::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TVarLen(";
  out << "payload=" << to_string(payload);
  out << ", " << "is_null=" << to_string(is_null);
  out << ")";
}


TDataBlockPtr::~TDataBlockPtr() noexcept {
}


void TDataBlockPtr::__set_fixed_len_data(const std::string& val) {
  this->fixed_len_data = val;
__isset.fixed_len_data = true;
}

void TDataBlockPtr::__set_var_len_data(const std::vector<TVarLen> & val) {
  this->var_len_data = val;
__isset.var_len_data = true;
}
std::ostream& operator<<(std::ostream& out, const TDataBlockPtr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDataBlockPtr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->fixed_len_data);
          this->__isset.fixed_len_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->var_len_data.clear();
            uint32_t _size241;
            ::apache::thrift::protocol::TType _etype244;
            xfer += iprot->readListBegin(_etype244, _size241);
            this->var_len_data.resize(_size241);
            uint32_t _i245;
            for (_i245 = 0; _i245 < _size241; ++_i245)
            {
              xfer += this->var_len_data[_i245].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.var_len_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDataBlockPtr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataBlockPtr");

  if (this->__isset.fixed_len_data) {
    xfer += oprot->writeFieldBegin("fixed_len_data", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->fixed_len_data);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.var_len_data) {
    xfer += oprot->writeFieldBegin("var_len_data", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->var_len_data.size()));
      std::vector<TVarLen> ::const_iterator _iter246;
      for (_iter246 = this->var_len_data.begin(); _iter246 != this->var_len_data.end(); ++_iter246)
      {
        xfer += (*_iter246).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataBlockPtr &a, TDataBlockPtr &b) {
  using ::std::swap;
  swap(a.fixed_len_data, b.fixed_len_data);
  swap(a.var_len_data, b.var_len_data);
  swap(a.__isset, b.__isset);
}

TDataBlockPtr::TDataBlockPtr(const TDataBlockPtr& other247) {
  fixed_len_data = other247.fixed_len_data;
  var_len_data = other247.var_len_data;
  __isset = other247.__isset;
}
TDataBlockPtr& TDataBlockPtr::operator=(const TDataBlockPtr& other248) {
  fixed_len_data = other248.fixed_len_data;
  var_len_data = other248.var_len_data;
  __isset = other248.__isset;
  return *this;
}
void TDataBlockPtr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataBlockPtr(";
  out << "fixed_len_data="; (__isset.fixed_len_data ? (out << to_string(fixed_len_data)) : (out << "<null>"));
  out << ", " << "var_len_data="; (__isset.var_len_data ? (out << to_string(var_len_data)) : (out << "<null>"));
  out << ")";
}


TInsertData::~TInsertData() noexcept {
}


void TInsertData::__set_db_id(const int32_t val) {
  this->db_id = val;
}

void TInsertData::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TInsertData::__set_column_ids(const std::vector<int32_t> & val) {
  this->column_ids = val;
}

void TInsertData::__set_data(const std::vector<TDataBlockPtr> & val) {
  this->data = val;
}

void TInsertData::__set_num_rows(const int64_t val) {
  this->num_rows = val;
}

void TInsertData::__set_is_default(const std::vector<bool> & val) {
  this->is_default = val;
}
std::ostream& operator<<(std::ostream& out, const TInsertData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TInsertData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->db_id);
          this->__isset.db_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_ids.clear();
            uint32_t _size249;
            ::apache::thrift::protocol::TType _etype252;
            xfer += iprot->readListBegin(_etype252, _size249);
            this->column_ids.resize(_size249);
            uint32_t _i253;
            for (_i253 = 0; _i253 < _size249; ++_i253)
            {
              xfer += iprot->readI32(this->column_ids[_i253]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size254;
            ::apache::thrift::protocol::TType _etype257;
            xfer += iprot->readListBegin(_etype257, _size254);
            this->data.resize(_size254);
            uint32_t _i258;
            for (_i258 = 0; _i258 < _size254; ++_i258)
            {
              xfer += this->data[_i258].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_rows);
          this->__isset.num_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->is_default.clear();
            uint32_t _size259;
            ::apache::thrift::protocol::TType _etype262;
            xfer += iprot->readListBegin(_etype262, _size259);
            this->is_default.resize(_size259);
            uint32_t _i263;
            for (_i263 = 0; _i263 < _size259; ++_i263)
            {
              xfer += iprot->readBool(this->is_default[_i263]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.is_default = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TInsertData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TInsertData");

  xfer += oprot->writeFieldBegin("db_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->db_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_ids", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->column_ids.size()));
    std::vector<int32_t> ::const_iterator _iter264;
    for (_iter264 = this->column_ids.begin(); _iter264 != this->column_ids.end(); ++_iter264)
    {
      xfer += oprot->writeI32((*_iter264));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->data.size()));
    std::vector<TDataBlockPtr> ::const_iterator _iter265;
    for (_iter265 = this->data.begin(); _iter265 != this->data.end(); ++_iter265)
    {
      xfer += (*_iter265).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_rows", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->num_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_default", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->is_default.size()));
    std::vector<bool> ::const_iterator _iter266;
    for (_iter266 = this->is_default.begin(); _iter266 != this->is_default.end(); ++_iter266)
    {
      xfer += oprot->writeBool((*_iter266));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TInsertData &a, TInsertData &b) {
  using ::std::swap;
  swap(a.db_id, b.db_id);
  swap(a.table_id, b.table_id);
  swap(a.column_ids, b.column_ids);
  swap(a.data, b.data);
  swap(a.num_rows, b.num_rows);
  swap(a.is_default, b.is_default);
  swap(a.__isset, b.__isset);
}

TInsertData::TInsertData(const TInsertData& other267) {
  db_id = other267.db_id;
  table_id = other267.table_id;
  column_ids = other267.column_ids;
  data = other267.data;
  num_rows = other267.num_rows;
  is_default = other267.is_default;
  __isset = other267.__isset;
}
TInsertData& TInsertData::operator=(const TInsertData& other268) {
  db_id = other268.db_id;
  table_id = other268.table_id;
  column_ids = other268.column_ids;
  data = other268.data;
  num_rows = other268.num_rows;
  is_default = other268.is_default;
  __isset = other268.__isset;
  return *this;
}
void TInsertData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TInsertData(";
  out << "db_id=" << to_string(db_id);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "column_ids=" << to_string(column_ids);
  out << ", " << "data=" << to_string(data);
  out << ", " << "num_rows=" << to_string(num_rows);
  out << ", " << "is_default=" << to_string(is_default);
  out << ")";
}


TChunkData::~TChunkData() noexcept {
}


void TChunkData::__set_data_buffer(const std::string& val) {
  this->data_buffer = val;
__isset.data_buffer = true;
}

void TChunkData::__set_index_buffer(const std::string& val) {
  this->index_buffer = val;
__isset.index_buffer = true;
}
std::ostream& operator<<(std::ostream& out, const TChunkData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TChunkData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data_buffer);
          this->__isset.data_buffer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->index_buffer);
          this->__isset.index_buffer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TChunkData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChunkData");

  if (this->__isset.data_buffer) {
    xfer += oprot->writeFieldBegin("data_buffer", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->data_buffer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.index_buffer) {
    xfer += oprot->writeFieldBegin("index_buffer", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->index_buffer);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TChunkData &a, TChunkData &b) {
  using ::std::swap;
  swap(a.data_buffer, b.data_buffer);
  swap(a.index_buffer, b.index_buffer);
  swap(a.__isset, b.__isset);
}

TChunkData::TChunkData(const TChunkData& other269) {
  data_buffer = other269.data_buffer;
  index_buffer = other269.index_buffer;
  __isset = other269.__isset;
}
TChunkData& TChunkData::operator=(const TChunkData& other270) {
  data_buffer = other270.data_buffer;
  index_buffer = other270.index_buffer;
  __isset = other270.__isset;
  return *this;
}
void TChunkData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TChunkData(";
  out << "data_buffer="; (__isset.data_buffer ? (out << to_string(data_buffer)) : (out << "<null>"));
  out << ", " << "index_buffer="; (__isset.index_buffer ? (out << to_string(index_buffer)) : (out << "<null>"));
  out << ")";
}


TInsertChunks::~TInsertChunks() noexcept {
}


void TInsertChunks::__set_db_id(const int32_t val) {
  this->db_id = val;
}

void TInsertChunks::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TInsertChunks::__set_data(const std::vector<TChunkData> & val) {
  this->data = val;
}

void TInsertChunks::__set_valid_indices(const std::vector<int64_t> & val) {
  this->valid_indices = val;
}

void TInsertChunks::__set_num_rows(const int64_t val) {
  this->num_rows = val;
}
std::ostream& operator<<(std::ostream& out, const TInsertChunks& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TInsertChunks::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->db_id);
          this->__isset.db_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size271;
            ::apache::thrift::protocol::TType _etype274;
            xfer += iprot->readListBegin(_etype274, _size271);
            this->data.resize(_size271);
            uint32_t _i275;
            for (_i275 = 0; _i275 < _size271; ++_i275)
            {
              xfer += this->data[_i275].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valid_indices.clear();
            uint32_t _size276;
            ::apache::thrift::protocol::TType _etype279;
            xfer += iprot->readListBegin(_etype279, _size276);
            this->valid_indices.resize(_size276);
            uint32_t _i280;
            for (_i280 = 0; _i280 < _size276; ++_i280)
            {
              xfer += iprot->readI64(this->valid_indices[_i280]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.valid_indices = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_rows);
          this->__isset.num_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TInsertChunks::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TInsertChunks");

  xfer += oprot->writeFieldBegin("db_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->db_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->data.size()));
    std::vector<TChunkData> ::const_iterator _iter281;
    for (_iter281 = this->data.begin(); _iter281 != this->data.end(); ++_iter281)
    {
      xfer += (*_iter281).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valid_indices", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->valid_indices.size()));
    std::vector<int64_t> ::const_iterator _iter282;
    for (_iter282 = this->valid_indices.begin(); _iter282 != this->valid_indices.end(); ++_iter282)
    {
      xfer += oprot->writeI64((*_iter282));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_rows", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->num_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TInsertChunks &a, TInsertChunks &b) {
  using ::std::swap;
  swap(a.db_id, b.db_id);
  swap(a.table_id, b.table_id);
  swap(a.data, b.data);
  swap(a.valid_indices, b.valid_indices);
  swap(a.num_rows, b.num_rows);
  swap(a.__isset, b.__isset);
}

TInsertChunks::TInsertChunks(const TInsertChunks& other283) {
  db_id = other283.db_id;
  table_id = other283.table_id;
  data = other283.data;
  valid_indices = other283.valid_indices;
  num_rows = other283.num_rows;
  __isset = other283.__isset;
}
TInsertChunks& TInsertChunks::operator=(const TInsertChunks& other284) {
  db_id = other284.db_id;
  table_id = other284.table_id;
  data = other284.data;
  valid_indices = other284.valid_indices;
  num_rows = other284.num_rows;
  __isset = other284.__isset;
  return *this;
}
void TInsertChunks::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TInsertChunks(";
  out << "db_id=" << to_string(db_id);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "data=" << to_string(data);
  out << ", " << "valid_indices=" << to_string(valid_indices);
  out << ", " << "num_rows=" << to_string(num_rows);
  out << ")";
}


TPendingRenderQuery::~TPendingRenderQuery() noexcept {
}


void TPendingRenderQuery::__set_id(const TQueryId val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const TPendingRenderQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPendingRenderQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPendingRenderQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPendingRenderQuery");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPendingRenderQuery &a, TPendingRenderQuery &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

TPendingRenderQuery::TPendingRenderQuery(const TPendingRenderQuery& other285) noexcept {
  id = other285.id;
  __isset = other285.__isset;
}
TPendingRenderQuery& TPendingRenderQuery::operator=(const TPendingRenderQuery& other286) noexcept {
  id = other286.id;
  __isset = other286.__isset;
  return *this;
}
void TPendingRenderQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPendingRenderQuery(";
  out << "id=" << to_string(id);
  out << ")";
}


TRenderParseResult::~TRenderParseResult() noexcept {
}


void TRenderParseResult::__set_merge_type(const TMergeType::type val) {
  this->merge_type = val;
}

void TRenderParseResult::__set_node_id(const int32_t val) {
  this->node_id = val;
}

void TRenderParseResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TRenderParseResult::__set_render_time_ms(const int64_t val) {
  this->render_time_ms = val;
}

void TRenderParseResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderParseResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderParseResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast287;
          xfer += iprot->readI32(ecast287);
          this->merge_type = static_cast<TMergeType::type>(ecast287);
          this->__isset.merge_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->render_time_ms);
          this->__isset.render_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderParseResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderParseResult");

  xfer += oprot->writeFieldBegin("merge_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->merge_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_time_ms", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->render_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderParseResult &a, TRenderParseResult &b) {
  using ::std::swap;
  swap(a.merge_type, b.merge_type);
  swap(a.node_id, b.node_id);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.render_time_ms, b.render_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.__isset, b.__isset);
}

TRenderParseResult::TRenderParseResult(const TRenderParseResult& other288) noexcept {
  merge_type = other288.merge_type;
  node_id = other288.node_id;
  execution_time_ms = other288.execution_time_ms;
  render_time_ms = other288.render_time_ms;
  total_time_ms = other288.total_time_ms;
  __isset = other288.__isset;
}
TRenderParseResult& TRenderParseResult::operator=(const TRenderParseResult& other289) noexcept {
  merge_type = other289.merge_type;
  node_id = other289.node_id;
  execution_time_ms = other289.execution_time_ms;
  render_time_ms = other289.render_time_ms;
  total_time_ms = other289.total_time_ms;
  __isset = other289.__isset;
  return *this;
}
void TRenderParseResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderParseResult(";
  out << "merge_type=" << to_string(merge_type);
  out << ", " << "node_id=" << to_string(node_id);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "render_time_ms=" << to_string(render_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ")";
}


TRawRenderPassDataResult::~TRawRenderPassDataResult() noexcept {
}


void TRawRenderPassDataResult::__set_num_pixel_channels(const int32_t val) {
  this->num_pixel_channels = val;
}

void TRawRenderPassDataResult::__set_num_pixel_samples(const int32_t val) {
  this->num_pixel_samples = val;
}

void TRawRenderPassDataResult::__set_pixels(const std::string& val) {
  this->pixels = val;
}

void TRawRenderPassDataResult::__set_row_ids_A(const std::string& val) {
  this->row_ids_A = val;
}

void TRawRenderPassDataResult::__set_row_ids_B(const std::string& val) {
  this->row_ids_B = val;
}

void TRawRenderPassDataResult::__set_table_ids(const std::string& val) {
  this->table_ids = val;
}

void TRawRenderPassDataResult::__set_accum_data(const std::string& val) {
  this->accum_data = val;
}

void TRawRenderPassDataResult::__set_accum_depth(const int32_t val) {
  this->accum_depth = val;
}
std::ostream& operator<<(std::ostream& out, const TRawRenderPassDataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRawRenderPassDataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_pixel_channels);
          this->__isset.num_pixel_channels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_pixel_samples);
          this->__isset.num_pixel_samples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pixels);
          this->__isset.pixels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row_ids_A);
          this->__isset.row_ids_A = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row_ids_B);
          this->__isset.row_ids_B = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->table_ids);
          this->__isset.table_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->accum_data);
          this->__isset.accum_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->accum_depth);
          this->__isset.accum_depth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRawRenderPassDataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRawRenderPassDataResult");

  xfer += oprot->writeFieldBegin("num_pixel_channels", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_pixel_channels);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_pixel_samples", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num_pixel_samples);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pixels", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->pixels);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_ids_A", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->row_ids_A);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_ids_B", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->row_ids_B);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_ids", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->table_ids);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accum_data", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeBinary(this->accum_data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accum_depth", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->accum_depth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRawRenderPassDataResult &a, TRawRenderPassDataResult &b) {
  using ::std::swap;
  swap(a.num_pixel_channels, b.num_pixel_channels);
  swap(a.num_pixel_samples, b.num_pixel_samples);
  swap(a.pixels, b.pixels);
  swap(a.row_ids_A, b.row_ids_A);
  swap(a.row_ids_B, b.row_ids_B);
  swap(a.table_ids, b.table_ids);
  swap(a.accum_data, b.accum_data);
  swap(a.accum_depth, b.accum_depth);
  swap(a.__isset, b.__isset);
}

TRawRenderPassDataResult::TRawRenderPassDataResult(const TRawRenderPassDataResult& other290) {
  num_pixel_channels = other290.num_pixel_channels;
  num_pixel_samples = other290.num_pixel_samples;
  pixels = other290.pixels;
  row_ids_A = other290.row_ids_A;
  row_ids_B = other290.row_ids_B;
  table_ids = other290.table_ids;
  accum_data = other290.accum_data;
  accum_depth = other290.accum_depth;
  __isset = other290.__isset;
}
TRawRenderPassDataResult& TRawRenderPassDataResult::operator=(const TRawRenderPassDataResult& other291) {
  num_pixel_channels = other291.num_pixel_channels;
  num_pixel_samples = other291.num_pixel_samples;
  pixels = other291.pixels;
  row_ids_A = other291.row_ids_A;
  row_ids_B = other291.row_ids_B;
  table_ids = other291.table_ids;
  accum_data = other291.accum_data;
  accum_depth = other291.accum_depth;
  __isset = other291.__isset;
  return *this;
}
void TRawRenderPassDataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRawRenderPassDataResult(";
  out << "num_pixel_channels=" << to_string(num_pixel_channels);
  out << ", " << "num_pixel_samples=" << to_string(num_pixel_samples);
  out << ", " << "pixels=" << to_string(pixels);
  out << ", " << "row_ids_A=" << to_string(row_ids_A);
  out << ", " << "row_ids_B=" << to_string(row_ids_B);
  out << ", " << "table_ids=" << to_string(table_ids);
  out << ", " << "accum_data=" << to_string(accum_data);
  out << ", " << "accum_depth=" << to_string(accum_depth);
  out << ")";
}


TRawPixelData::~TRawPixelData() noexcept {
}


void TRawPixelData::__set_width(const int32_t val) {
  this->width = val;
}

void TRawPixelData::__set_height(const int32_t val) {
  this->height = val;
}

void TRawPixelData::__set_render_pass_map(const TRenderPassMap& val) {
  this->render_pass_map = val;
}
std::ostream& operator<<(std::ostream& out, const TRawPixelData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRawPixelData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          this->__isset.height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->render_pass_map.clear();
            uint32_t _size292;
            ::apache::thrift::protocol::TType _ktype293;
            ::apache::thrift::protocol::TType _vtype294;
            xfer += iprot->readMapBegin(_ktype293, _vtype294, _size292);
            uint32_t _i296;
            for (_i296 = 0; _i296 < _size292; ++_i296)
            {
              int32_t _key297;
              xfer += iprot->readI32(_key297);
              TRawRenderPassDataResult& _val298 = this->render_pass_map[_key297];
              xfer += _val298.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.render_pass_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRawPixelData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRawPixelData");

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_pass_map", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->render_pass_map.size()));
    std::map<int32_t, TRawRenderPassDataResult> ::const_iterator _iter299;
    for (_iter299 = this->render_pass_map.begin(); _iter299 != this->render_pass_map.end(); ++_iter299)
    {
      xfer += oprot->writeI32(_iter299->first);
      xfer += _iter299->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRawPixelData &a, TRawPixelData &b) {
  using ::std::swap;
  swap(a.width, b.width);
  swap(a.height, b.height);
  swap(a.render_pass_map, b.render_pass_map);
  swap(a.__isset, b.__isset);
}

TRawPixelData::TRawPixelData(const TRawPixelData& other300) {
  width = other300.width;
  height = other300.height;
  render_pass_map = other300.render_pass_map;
  __isset = other300.__isset;
}
TRawPixelData& TRawPixelData::operator=(const TRawPixelData& other301) {
  width = other301.width;
  height = other301.height;
  render_pass_map = other301.render_pass_map;
  __isset = other301.__isset;
  return *this;
}
void TRawPixelData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRawPixelData(";
  out << "width=" << to_string(width);
  out << ", " << "height=" << to_string(height);
  out << ", " << "render_pass_map=" << to_string(render_pass_map);
  out << ")";
}


TRenderDatum::~TRenderDatum() noexcept {
}


void TRenderDatum::__set_type(const  ::TDatumType::type val) {
  this->type = val;
}

void TRenderDatum::__set_cnt(const int32_t val) {
  this->cnt = val;
}

void TRenderDatum::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderDatum& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderDatum::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast302;
          xfer += iprot->readI32(ecast302);
          this->type = static_cast< ::TDatumType::type>(ecast302);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cnt);
          this->__isset.cnt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderDatum::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderDatum");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cnt", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->cnt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderDatum &a, TRenderDatum &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.cnt, b.cnt);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TRenderDatum::TRenderDatum(const TRenderDatum& other303) {
  type = other303.type;
  cnt = other303.cnt;
  value = other303.value;
  __isset = other303.__isset;
}
TRenderDatum& TRenderDatum::operator=(const TRenderDatum& other304) {
  type = other304.type;
  cnt = other304.cnt;
  value = other304.value;
  __isset = other304.__isset;
  return *this;
}
void TRenderDatum::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderDatum(";
  out << "type=" << to_string(type);
  out << ", " << "cnt=" << to_string(cnt);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


TRenderStepResult::~TRenderStepResult() noexcept {
}


void TRenderStepResult::__set_merge_data(const TRenderAggDataMap& val) {
  this->merge_data = val;
}

void TRenderStepResult::__set_raw_pixel_data(const TRawPixelData& val) {
  this->raw_pixel_data = val;
}

void TRenderStepResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TRenderStepResult::__set_render_time_ms(const int64_t val) {
  this->render_time_ms = val;
}

void TRenderStepResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderStepResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderStepResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->merge_data.clear();
            uint32_t _size305;
            ::apache::thrift::protocol::TType _ktype306;
            ::apache::thrift::protocol::TType _vtype307;
            xfer += iprot->readMapBegin(_ktype306, _vtype307, _size305);
            uint32_t _i309;
            for (_i309 = 0; _i309 < _size305; ++_i309)
            {
              std::string _key310;
              xfer += iprot->readString(_key310);
              std::map<std::string, std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > > & _val311 = this->merge_data[_key310];
              {
                _val311.clear();
                uint32_t _size312;
                ::apache::thrift::protocol::TType _ktype313;
                ::apache::thrift::protocol::TType _vtype314;
                xfer += iprot->readMapBegin(_ktype313, _vtype314, _size312);
                uint32_t _i316;
                for (_i316 = 0; _i316 < _size312; ++_i316)
                {
                  std::string _key317;
                  xfer += iprot->readString(_key317);
                  std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > & _val318 = _val311[_key317];
                  {
                    _val318.clear();
                    uint32_t _size319;
                    ::apache::thrift::protocol::TType _ktype320;
                    ::apache::thrift::protocol::TType _vtype321;
                    xfer += iprot->readMapBegin(_ktype320, _vtype321, _size319);
                    uint32_t _i323;
                    for (_i323 = 0; _i323 < _size319; ++_i323)
                    {
                      std::string _key324;
                      xfer += iprot->readString(_key324);
                      std::map<std::string, std::vector<TRenderDatum> > & _val325 = _val318[_key324];
                      {
                        _val325.clear();
                        uint32_t _size326;
                        ::apache::thrift::protocol::TType _ktype327;
                        ::apache::thrift::protocol::TType _vtype328;
                        xfer += iprot->readMapBegin(_ktype327, _vtype328, _size326);
                        uint32_t _i330;
                        for (_i330 = 0; _i330 < _size326; ++_i330)
                        {
                          std::string _key331;
                          xfer += iprot->readString(_key331);
                          std::vector<TRenderDatum> & _val332 = _val325[_key331];
                          {
                            _val332.clear();
                            uint32_t _size333;
                            ::apache::thrift::protocol::TType _etype336;
                            xfer += iprot->readListBegin(_etype336, _size333);
                            _val332.resize(_size333);
                            uint32_t _i337;
                            for (_i337 = 0; _i337 < _size333; ++_i337)
                            {
                              xfer += _val332[_i337].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                          }
                        }
                        xfer += iprot->readMapEnd();
                      }
                    }
                    xfer += iprot->readMapEnd();
                  }
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.merge_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->raw_pixel_data.read(iprot);
          this->__isset.raw_pixel_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->render_time_ms);
          this->__isset.render_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderStepResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderStepResult");

  xfer += oprot->writeFieldBegin("merge_data", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->merge_data.size()));
    std::map<std::string, std::map<std::string, std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > > > ::const_iterator _iter338;
    for (_iter338 = this->merge_data.begin(); _iter338 != this->merge_data.end(); ++_iter338)
    {
      xfer += oprot->writeString(_iter338->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(_iter338->second.size()));
        std::map<std::string, std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > > ::const_iterator _iter339;
        for (_iter339 = _iter338->second.begin(); _iter339 != _iter338->second.end(); ++_iter339)
        {
          xfer += oprot->writeString(_iter339->first);
          {
            xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(_iter339->second.size()));
            std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > ::const_iterator _iter340;
            for (_iter340 = _iter339->second.begin(); _iter340 != _iter339->second.end(); ++_iter340)
            {
              xfer += oprot->writeString(_iter340->first);
              {
                xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(_iter340->second.size()));
                std::map<std::string, std::vector<TRenderDatum> > ::const_iterator _iter341;
                for (_iter341 = _iter340->second.begin(); _iter341 != _iter340->second.end(); ++_iter341)
                {
                  xfer += oprot->writeString(_iter341->first);
                  {
                    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter341->second.size()));
                    std::vector<TRenderDatum> ::const_iterator _iter342;
                    for (_iter342 = _iter341->second.begin(); _iter342 != _iter341->second.end(); ++_iter342)
                    {
                      xfer += (*_iter342).write(oprot);
                    }
                    xfer += oprot->writeListEnd();
                  }
                }
                xfer += oprot->writeMapEnd();
              }
            }
            xfer += oprot->writeMapEnd();
          }
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raw_pixel_data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->raw_pixel_data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_time_ms", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->render_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderStepResult &a, TRenderStepResult &b) {
  using ::std::swap;
  swap(a.merge_data, b.merge_data);
  swap(a.raw_pixel_data, b.raw_pixel_data);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.render_time_ms, b.render_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.__isset, b.__isset);
}

TRenderStepResult::TRenderStepResult(const TRenderStepResult& other343) {
  merge_data = other343.merge_data;
  raw_pixel_data = other343.raw_pixel_data;
  execution_time_ms = other343.execution_time_ms;
  render_time_ms = other343.render_time_ms;
  total_time_ms = other343.total_time_ms;
  __isset = other343.__isset;
}
TRenderStepResult& TRenderStepResult::operator=(const TRenderStepResult& other344) {
  merge_data = other344.merge_data;
  raw_pixel_data = other344.raw_pixel_data;
  execution_time_ms = other344.execution_time_ms;
  render_time_ms = other344.render_time_ms;
  total_time_ms = other344.total_time_ms;
  __isset = other344.__isset;
  return *this;
}
void TRenderStepResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderStepResult(";
  out << "merge_data=" << to_string(merge_data);
  out << ", " << "raw_pixel_data=" << to_string(raw_pixel_data);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "render_time_ms=" << to_string(render_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ")";
}


TDatabasePermissions::~TDatabasePermissions() noexcept {
}


void TDatabasePermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TDatabasePermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}

void TDatabasePermissions::__set_view_sql_editor_(const bool val) {
  this->view_sql_editor_ = val;
}

void TDatabasePermissions::__set_access_(const bool val) {
  this->access_ = val;
}
std::ostream& operator<<(std::ostream& out, const TDatabasePermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDatabasePermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->view_sql_editor_);
          this->__isset.view_sql_editor_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->access_);
          this->__isset.access_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDatabasePermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDatabasePermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_sql_editor_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->view_sql_editor_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("access_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->access_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDatabasePermissions &a, TDatabasePermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.delete_, b.delete_);
  swap(a.view_sql_editor_, b.view_sql_editor_);
  swap(a.access_, b.access_);
  swap(a.__isset, b.__isset);
}

TDatabasePermissions::TDatabasePermissions(const TDatabasePermissions& other345) noexcept {
  create_ = other345.create_;
  delete_ = other345.delete_;
  view_sql_editor_ = other345.view_sql_editor_;
  access_ = other345.access_;
  __isset = other345.__isset;
}
TDatabasePermissions& TDatabasePermissions::operator=(const TDatabasePermissions& other346) noexcept {
  create_ = other346.create_;
  delete_ = other346.delete_;
  view_sql_editor_ = other346.view_sql_editor_;
  access_ = other346.access_;
  __isset = other346.__isset;
  return *this;
}
void TDatabasePermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDatabasePermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ", " << "view_sql_editor_=" << to_string(view_sql_editor_);
  out << ", " << "access_=" << to_string(access_);
  out << ")";
}


TTablePermissions::~TTablePermissions() noexcept {
}


void TTablePermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TTablePermissions::__set_drop_(const bool val) {
  this->drop_ = val;
}

void TTablePermissions::__set_select_(const bool val) {
  this->select_ = val;
}

void TTablePermissions::__set_insert_(const bool val) {
  this->insert_ = val;
}

void TTablePermissions::__set_update_(const bool val) {
  this->update_ = val;
}

void TTablePermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}

void TTablePermissions::__set_truncate_(const bool val) {
  this->truncate_ = val;
}

void TTablePermissions::__set_alter_(const bool val) {
  this->alter_ = val;
}
std::ostream& operator<<(std::ostream& out, const TTablePermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTablePermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->drop_);
          this->__isset.drop_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->select_);
          this->__isset.select_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->insert_);
          this->__isset.insert_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->update_);
          this->__isset.update_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->truncate_);
          this->__isset.truncate_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->alter_);
          this->__isset.alter_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTablePermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTablePermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("drop_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->drop_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("select_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->select_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("insert_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->insert_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->update_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("truncate_", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->truncate_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("alter_", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->alter_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTablePermissions &a, TTablePermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.drop_, b.drop_);
  swap(a.select_, b.select_);
  swap(a.insert_, b.insert_);
  swap(a.update_, b.update_);
  swap(a.delete_, b.delete_);
  swap(a.truncate_, b.truncate_);
  swap(a.alter_, b.alter_);
  swap(a.__isset, b.__isset);
}

TTablePermissions::TTablePermissions(const TTablePermissions& other347) noexcept {
  create_ = other347.create_;
  drop_ = other347.drop_;
  select_ = other347.select_;
  insert_ = other347.insert_;
  update_ = other347.update_;
  delete_ = other347.delete_;
  truncate_ = other347.truncate_;
  alter_ = other347.alter_;
  __isset = other347.__isset;
}
TTablePermissions& TTablePermissions::operator=(const TTablePermissions& other348) noexcept {
  create_ = other348.create_;
  drop_ = other348.drop_;
  select_ = other348.select_;
  insert_ = other348.insert_;
  update_ = other348.update_;
  delete_ = other348.delete_;
  truncate_ = other348.truncate_;
  alter_ = other348.alter_;
  __isset = other348.__isset;
  return *this;
}
void TTablePermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTablePermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "drop_=" << to_string(drop_);
  out << ", " << "select_=" << to_string(select_);
  out << ", " << "insert_=" << to_string(insert_);
  out << ", " << "update_=" << to_string(update_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ", " << "truncate_=" << to_string(truncate_);
  out << ", " << "alter_=" << to_string(alter_);
  out << ")";
}


TDashboardPermissions::~TDashboardPermissions() noexcept {
}


void TDashboardPermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TDashboardPermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}

void TDashboardPermissions::__set_view_(const bool val) {
  this->view_ = val;
}

void TDashboardPermissions::__set_edit_(const bool val) {
  this->edit_ = val;
}
std::ostream& operator<<(std::ostream& out, const TDashboardPermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDashboardPermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->view_);
          this->__isset.view_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->edit_);
          this->__isset.edit_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDashboardPermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDashboardPermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->view_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("edit_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->edit_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDashboardPermissions &a, TDashboardPermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.delete_, b.delete_);
  swap(a.view_, b.view_);
  swap(a.edit_, b.edit_);
  swap(a.__isset, b.__isset);
}

TDashboardPermissions::TDashboardPermissions(const TDashboardPermissions& other349) noexcept {
  create_ = other349.create_;
  delete_ = other349.delete_;
  view_ = other349.view_;
  edit_ = other349.edit_;
  __isset = other349.__isset;
}
TDashboardPermissions& TDashboardPermissions::operator=(const TDashboardPermissions& other350) noexcept {
  create_ = other350.create_;
  delete_ = other350.delete_;
  view_ = other350.view_;
  edit_ = other350.edit_;
  __isset = other350.__isset;
  return *this;
}
void TDashboardPermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDashboardPermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ", " << "view_=" << to_string(view_);
  out << ", " << "edit_=" << to_string(edit_);
  out << ")";
}


TViewPermissions::~TViewPermissions() noexcept {
}


void TViewPermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TViewPermissions::__set_drop_(const bool val) {
  this->drop_ = val;
}

void TViewPermissions::__set_select_(const bool val) {
  this->select_ = val;
}

void TViewPermissions::__set_insert_(const bool val) {
  this->insert_ = val;
}

void TViewPermissions::__set_update_(const bool val) {
  this->update_ = val;
}

void TViewPermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}
std::ostream& operator<<(std::ostream& out, const TViewPermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TViewPermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->drop_);
          this->__isset.drop_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->select_);
          this->__isset.select_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->insert_);
          this->__isset.insert_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->update_);
          this->__isset.update_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TViewPermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TViewPermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("drop_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->drop_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("select_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->select_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("insert_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->insert_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->update_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TViewPermissions &a, TViewPermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.drop_, b.drop_);
  swap(a.select_, b.select_);
  swap(a.insert_, b.insert_);
  swap(a.update_, b.update_);
  swap(a.delete_, b.delete_);
  swap(a.__isset, b.__isset);
}

TViewPermissions::TViewPermissions(const TViewPermissions& other351) noexcept {
  create_ = other351.create_;
  drop_ = other351.drop_;
  select_ = other351.select_;
  insert_ = other351.insert_;
  update_ = other351.update_;
  delete_ = other351.delete_;
  __isset = other351.__isset;
}
TViewPermissions& TViewPermissions::operator=(const TViewPermissions& other352) noexcept {
  create_ = other352.create_;
  drop_ = other352.drop_;
  select_ = other352.select_;
  insert_ = other352.insert_;
  update_ = other352.update_;
  delete_ = other352.delete_;
  __isset = other352.__isset;
  return *this;
}
void TViewPermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TViewPermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "drop_=" << to_string(drop_);
  out << ", " << "select_=" << to_string(select_);
  out << ", " << "insert_=" << to_string(insert_);
  out << ", " << "update_=" << to_string(update_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ")";
}


TServerPermissions::~TServerPermissions() noexcept {
}


void TServerPermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TServerPermissions::__set_drop_(const bool val) {
  this->drop_ = val;
}

void TServerPermissions::__set_alter_(const bool val) {
  this->alter_ = val;
}

void TServerPermissions::__set_usage_(const bool val) {
  this->usage_ = val;
}
std::ostream& operator<<(std::ostream& out, const TServerPermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TServerPermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->drop_);
          this->__isset.drop_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->alter_);
          this->__isset.alter_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->usage_);
          this->__isset.usage_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TServerPermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TServerPermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("drop_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->drop_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("alter_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->alter_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usage_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->usage_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TServerPermissions &a, TServerPermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.drop_, b.drop_);
  swap(a.alter_, b.alter_);
  swap(a.usage_, b.usage_);
  swap(a.__isset, b.__isset);
}

TServerPermissions::TServerPermissions(const TServerPermissions& other353) noexcept {
  create_ = other353.create_;
  drop_ = other353.drop_;
  alter_ = other353.alter_;
  usage_ = other353.usage_;
  __isset = other353.__isset;
}
TServerPermissions& TServerPermissions::operator=(const TServerPermissions& other354) noexcept {
  create_ = other354.create_;
  drop_ = other354.drop_;
  alter_ = other354.alter_;
  usage_ = other354.usage_;
  __isset = other354.__isset;
  return *this;
}
void TServerPermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TServerPermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "drop_=" << to_string(drop_);
  out << ", " << "alter_=" << to_string(alter_);
  out << ", " << "usage_=" << to_string(usage_);
  out << ")";
}


TColumnPermissions::~TColumnPermissions() noexcept {
}


void TColumnPermissions::__set_select_(const bool val) {
  this->select_ = val;
}
std::ostream& operator<<(std::ostream& out, const TColumnPermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnPermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->select_);
          this->__isset.select_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnPermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnPermissions");

  xfer += oprot->writeFieldBegin("select_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->select_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnPermissions &a, TColumnPermissions &b) {
  using ::std::swap;
  swap(a.select_, b.select_);
  swap(a.__isset, b.__isset);
}

TColumnPermissions::TColumnPermissions(const TColumnPermissions& other355) noexcept {
  select_ = other355.select_;
  __isset = other355.__isset;
}
TColumnPermissions& TColumnPermissions::operator=(const TColumnPermissions& other356) noexcept {
  select_ = other356.select_;
  __isset = other356.__isset;
  return *this;
}
void TColumnPermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnPermissions(";
  out << "select_=" << to_string(select_);
  out << ")";
}


TDBObjectPermissions::~TDBObjectPermissions() noexcept {
}


void TDBObjectPermissions::__set_database_permissions_(const TDatabasePermissions& val) {
  this->database_permissions_ = val;
__isset.database_permissions_ = true;
}

void TDBObjectPermissions::__set_table_permissions_(const TTablePermissions& val) {
  this->table_permissions_ = val;
__isset.table_permissions_ = true;
}

void TDBObjectPermissions::__set_dashboard_permissions_(const TDashboardPermissions& val) {
  this->dashboard_permissions_ = val;
__isset.dashboard_permissions_ = true;
}

void TDBObjectPermissions::__set_view_permissions_(const TViewPermissions& val) {
  this->view_permissions_ = val;
__isset.view_permissions_ = true;
}

void TDBObjectPermissions::__set_server_permissions_(const TServerPermissions& val) {
  this->server_permissions_ = val;
__isset.server_permissions_ = true;
}

void TDBObjectPermissions::__set_column_permissions_(const TColumnPermissions& val) {
  this->column_permissions_ = val;
__isset.column_permissions_ = true;
}
std::ostream& operator<<(std::ostream& out, const TDBObjectPermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDBObjectPermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->database_permissions_.read(iprot);
          this->__isset.database_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_permissions_.read(iprot);
          this->__isset.table_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dashboard_permissions_.read(iprot);
          this->__isset.dashboard_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->view_permissions_.read(iprot);
          this->__isset.view_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->server_permissions_.read(iprot);
          this->__isset.server_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->column_permissions_.read(iprot);
          this->__isset.column_permissions_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDBObjectPermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDBObjectPermissions");

  if (this->__isset.database_permissions_) {
    xfer += oprot->writeFieldBegin("database_permissions_", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->database_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_permissions_) {
    xfer += oprot->writeFieldBegin("table_permissions_", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->table_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dashboard_permissions_) {
    xfer += oprot->writeFieldBegin("dashboard_permissions_", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->dashboard_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.view_permissions_) {
    xfer += oprot->writeFieldBegin("view_permissions_", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->view_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.server_permissions_) {
    xfer += oprot->writeFieldBegin("server_permissions_", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->server_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_permissions_) {
    xfer += oprot->writeFieldBegin("column_permissions_", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->column_permissions_.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDBObjectPermissions &a, TDBObjectPermissions &b) {
  using ::std::swap;
  swap(a.database_permissions_, b.database_permissions_);
  swap(a.table_permissions_, b.table_permissions_);
  swap(a.dashboard_permissions_, b.dashboard_permissions_);
  swap(a.view_permissions_, b.view_permissions_);
  swap(a.server_permissions_, b.server_permissions_);
  swap(a.column_permissions_, b.column_permissions_);
  swap(a.__isset, b.__isset);
}

TDBObjectPermissions::TDBObjectPermissions(const TDBObjectPermissions& other357) noexcept {
  database_permissions_ = other357.database_permissions_;
  table_permissions_ = other357.table_permissions_;
  dashboard_permissions_ = other357.dashboard_permissions_;
  view_permissions_ = other357.view_permissions_;
  server_permissions_ = other357.server_permissions_;
  column_permissions_ = other357.column_permissions_;
  __isset = other357.__isset;
}
TDBObjectPermissions& TDBObjectPermissions::operator=(const TDBObjectPermissions& other358) noexcept {
  database_permissions_ = other358.database_permissions_;
  table_permissions_ = other358.table_permissions_;
  dashboard_permissions_ = other358.dashboard_permissions_;
  view_permissions_ = other358.view_permissions_;
  server_permissions_ = other358.server_permissions_;
  column_permissions_ = other358.column_permissions_;
  __isset = other358.__isset;
  return *this;
}
void TDBObjectPermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDBObjectPermissions(";
  out << "database_permissions_="; (__isset.database_permissions_ ? (out << to_string(database_permissions_)) : (out << "<null>"));
  out << ", " << "table_permissions_="; (__isset.table_permissions_ ? (out << to_string(table_permissions_)) : (out << "<null>"));
  out << ", " << "dashboard_permissions_="; (__isset.dashboard_permissions_ ? (out << to_string(dashboard_permissions_)) : (out << "<null>"));
  out << ", " << "view_permissions_="; (__isset.view_permissions_ ? (out << to_string(view_permissions_)) : (out << "<null>"));
  out << ", " << "server_permissions_="; (__isset.server_permissions_ ? (out << to_string(server_permissions_)) : (out << "<null>"));
  out << ", " << "column_permissions_="; (__isset.column_permissions_ ? (out << to_string(column_permissions_)) : (out << "<null>"));
  out << ")";
}


TDBObject::~TDBObject() noexcept {
}


void TDBObject::__set_objectName(const std::string& val) {
  this->objectName = val;
}

void TDBObject::__set_objectType(const TDBObjectType::type val) {
  this->objectType = val;
}

void TDBObject::__set_privs(const std::vector<bool> & val) {
  this->privs = val;
}

void TDBObject::__set_grantee(const std::string& val) {
  this->grantee = val;
}

void TDBObject::__set_privilegeObjectType(const TDBObjectType::type val) {
  this->privilegeObjectType = val;
}

void TDBObject::__set_objectId(const int32_t val) {
  this->objectId = val;
}
std::ostream& operator<<(std::ostream& out, const TDBObject& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDBObject::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->objectName);
          this->__isset.objectName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast359;
          xfer += iprot->readI32(ecast359);
          this->objectType = static_cast<TDBObjectType::type>(ecast359);
          this->__isset.objectType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->privs.clear();
            uint32_t _size360;
            ::apache::thrift::protocol::TType _etype363;
            xfer += iprot->readListBegin(_etype363, _size360);
            this->privs.resize(_size360);
            uint32_t _i364;
            for (_i364 = 0; _i364 < _size360; ++_i364)
            {
              xfer += iprot->readBool(this->privs[_i364]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.privs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grantee);
          this->__isset.grantee = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast365;
          xfer += iprot->readI32(ecast365);
          this->privilegeObjectType = static_cast<TDBObjectType::type>(ecast365);
          this->__isset.privilegeObjectType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->objectId);
          this->__isset.objectId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDBObject::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDBObject");

  xfer += oprot->writeFieldBegin("objectName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->objectName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("objectType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->objectType));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privs", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->privs.size()));
    std::vector<bool> ::const_iterator _iter366;
    for (_iter366 = this->privs.begin(); _iter366 != this->privs.end(); ++_iter366)
    {
      xfer += oprot->writeBool((*_iter366));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantee", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->grantee);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privilegeObjectType", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(static_cast<int32_t>(this->privilegeObjectType));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("objectId", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->objectId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDBObject &a, TDBObject &b) {
  using ::std::swap;
  swap(a.objectName, b.objectName);
  swap(a.objectType, b.objectType);
  swap(a.privs, b.privs);
  swap(a.grantee, b.grantee);
  swap(a.privilegeObjectType, b.privilegeObjectType);
  swap(a.objectId, b.objectId);
  swap(a.__isset, b.__isset);
}

TDBObject::TDBObject(const TDBObject& other367) {
  objectName = other367.objectName;
  objectType = other367.objectType;
  privs = other367.privs;
  grantee = other367.grantee;
  privilegeObjectType = other367.privilegeObjectType;
  objectId = other367.objectId;
  __isset = other367.__isset;
}
TDBObject& TDBObject::operator=(const TDBObject& other368) {
  objectName = other368.objectName;
  objectType = other368.objectType;
  privs = other368.privs;
  grantee = other368.grantee;
  privilegeObjectType = other368.privilegeObjectType;
  objectId = other368.objectId;
  __isset = other368.__isset;
  return *this;
}
void TDBObject::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDBObject(";
  out << "objectName=" << to_string(objectName);
  out << ", " << "objectType=" << to_string(objectType);
  out << ", " << "privs=" << to_string(privs);
  out << ", " << "grantee=" << to_string(grantee);
  out << ", " << "privilegeObjectType=" << to_string(privilegeObjectType);
  out << ", " << "objectId=" << to_string(objectId);
  out << ")";
}


TDashboardGrantees::~TDashboardGrantees() noexcept {
}


void TDashboardGrantees::__set_name(const std::string& val) {
  this->name = val;
}

void TDashboardGrantees::__set_is_user(const bool val) {
  this->is_user = val;
}

void TDashboardGrantees::__set_permissions(const TDashboardPermissions& val) {
  this->permissions = val;
}
std::ostream& operator<<(std::ostream& out, const TDashboardGrantees& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDashboardGrantees::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_user);
          this->__isset.is_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->permissions.read(iprot);
          this->__isset.permissions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDashboardGrantees::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDashboardGrantees");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_user", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("permissions", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->permissions.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDashboardGrantees &a, TDashboardGrantees &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.is_user, b.is_user);
  swap(a.permissions, b.permissions);
  swap(a.__isset, b.__isset);
}

TDashboardGrantees::TDashboardGrantees(const TDashboardGrantees& other369) {
  name = other369.name;
  is_user = other369.is_user;
  permissions = other369.permissions;
  __isset = other369.__isset;
}
TDashboardGrantees& TDashboardGrantees::operator=(const TDashboardGrantees& other370) {
  name = other370.name;
  is_user = other370.is_user;
  permissions = other370.permissions;
  __isset = other370.__isset;
  return *this;
}
void TDashboardGrantees::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDashboardGrantees(";
  out << "name=" << to_string(name);
  out << ", " << "is_user=" << to_string(is_user);
  out << ", " << "permissions=" << to_string(permissions);
  out << ")";
}


TDashboard::~TDashboard() noexcept {
}


void TDashboard::__set_dashboard_name(const std::string& val) {
  this->dashboard_name = val;
}

void TDashboard::__set_dashboard_state(const std::string& val) {
  this->dashboard_state = val;
}

void TDashboard::__set_image_hash(const std::string& val) {
  this->image_hash = val;
}

void TDashboard::__set_update_time(const std::string& val) {
  this->update_time = val;
}

void TDashboard::__set_dashboard_metadata(const std::string& val) {
  this->dashboard_metadata = val;
}

void TDashboard::__set_dashboard_id(const int32_t val) {
  this->dashboard_id = val;
}

void TDashboard::__set_dashboard_owner(const std::string& val) {
  this->dashboard_owner = val;
}

void TDashboard::__set_is_dash_shared(const bool val) {
  this->is_dash_shared = val;
}

void TDashboard::__set_dashboard_permissions(const TDashboardPermissions& val) {
  this->dashboard_permissions = val;
}
std::ostream& operator<<(std::ostream& out, const TDashboard& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDashboard::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_name);
          this->__isset.dashboard_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_state);
          this->__isset.dashboard_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image_hash);
          this->__isset.image_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->update_time);
          this->__isset.update_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_metadata);
          this->__isset.dashboard_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dashboard_id);
          this->__isset.dashboard_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_owner);
          this->__isset.dashboard_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_dash_shared);
          this->__isset.is_dash_shared = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dashboard_permissions.read(iprot);
          this->__isset.dashboard_permissions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDashboard::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDashboard");

  xfer += oprot->writeFieldBegin("dashboard_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dashboard_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_state", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dashboard_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("image_hash", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->image_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_time", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->update_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_metadata", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->dashboard_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_id", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->dashboard_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_owner", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->dashboard_owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_dash_shared", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->is_dash_shared);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_permissions", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->dashboard_permissions.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDashboard &a, TDashboard &b) {
  using ::std::swap;
  swap(a.dashboard_name, b.dashboard_name);
  swap(a.dashboard_state, b.dashboard_state);
  swap(a.image_hash, b.image_hash);
  swap(a.update_time, b.update_time);
  swap(a.dashboard_metadata, b.dashboard_metadata);
  swap(a.dashboard_id, b.dashboard_id);
  swap(a.dashboard_owner, b.dashboard_owner);
  swap(a.is_dash_shared, b.is_dash_shared);
  swap(a.dashboard_permissions, b.dashboard_permissions);
  swap(a.__isset, b.__isset);
}

TDashboard::TDashboard(const TDashboard& other371) {
  dashboard_name = other371.dashboard_name;
  dashboard_state = other371.dashboard_state;
  image_hash = other371.image_hash;
  update_time = other371.update_time;
  dashboard_metadata = other371.dashboard_metadata;
  dashboard_id = other371.dashboard_id;
  dashboard_owner = other371.dashboard_owner;
  is_dash_shared = other371.is_dash_shared;
  dashboard_permissions = other371.dashboard_permissions;
  __isset = other371.__isset;
}
TDashboard& TDashboard::operator=(const TDashboard& other372) {
  dashboard_name = other372.dashboard_name;
  dashboard_state = other372.dashboard_state;
  image_hash = other372.image_hash;
  update_time = other372.update_time;
  dashboard_metadata = other372.dashboard_metadata;
  dashboard_id = other372.dashboard_id;
  dashboard_owner = other372.dashboard_owner;
  is_dash_shared = other372.is_dash_shared;
  dashboard_permissions = other372.dashboard_permissions;
  __isset = other372.__isset;
  return *this;
}
void TDashboard::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDashboard(";
  out << "dashboard_name=" << to_string(dashboard_name);
  out << ", " << "dashboard_state=" << to_string(dashboard_state);
  out << ", " << "image_hash=" << to_string(image_hash);
  out << ", " << "update_time=" << to_string(update_time);
  out << ", " << "dashboard_metadata=" << to_string(dashboard_metadata);
  out << ", " << "dashboard_id=" << to_string(dashboard_id);
  out << ", " << "dashboard_owner=" << to_string(dashboard_owner);
  out << ", " << "is_dash_shared=" << to_string(is_dash_shared);
  out << ", " << "dashboard_permissions=" << to_string(dashboard_permissions);
  out << ")";
}


TLicenseInfo::~TLicenseInfo() noexcept {
}


void TLicenseInfo::__set_claims(const std::vector<std::string> & val) {
  this->claims = val;
}
std::ostream& operator<<(std::ostream& out, const TLicenseInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TLicenseInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->claims.clear();
            uint32_t _size373;
            ::apache::thrift::protocol::TType _etype376;
            xfer += iprot->readListBegin(_etype376, _size373);
            this->claims.resize(_size373);
            uint32_t _i377;
            for (_i377 = 0; _i377 < _size373; ++_i377)
            {
              xfer += iprot->readString(this->claims[_i377]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.claims = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TLicenseInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLicenseInfo");

  xfer += oprot->writeFieldBegin("claims", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->claims.size()));
    std::vector<std::string> ::const_iterator _iter378;
    for (_iter378 = this->claims.begin(); _iter378 != this->claims.end(); ++_iter378)
    {
      xfer += oprot->writeString((*_iter378));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLicenseInfo &a, TLicenseInfo &b) {
  using ::std::swap;
  swap(a.claims, b.claims);
  swap(a.__isset, b.__isset);
}

TLicenseInfo::TLicenseInfo(const TLicenseInfo& other379) {
  claims = other379.claims;
  __isset = other379.__isset;
}
TLicenseInfo& TLicenseInfo::operator=(const TLicenseInfo& other380) {
  claims = other380.claims;
  __isset = other380.__isset;
  return *this;
}
void TLicenseInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLicenseInfo(";
  out << "claims=" << to_string(claims);
  out << ")";
}


TSessionInfo::~TSessionInfo() noexcept {
}


void TSessionInfo::__set_user(const std::string& val) {
  this->user = val;
}

void TSessionInfo::__set_database(const std::string& val) {
  this->database = val;
}

void TSessionInfo::__set_start_time(const int64_t val) {
  this->start_time = val;
}

void TSessionInfo::__set_is_super(const bool val) {
  this->is_super = val;
}
std::ostream& operator<<(std::ostream& out, const TSessionInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSessionInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database);
          this->__isset.database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_time);
          this->__isset.start_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_super);
          this->__isset.is_super = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TSessionInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSessionInfo");

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("database", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->database);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->start_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_super", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_super);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSessionInfo &a, TSessionInfo &b) {
  using ::std::swap;
  swap(a.user, b.user);
  swap(a.database, b.database);
  swap(a.start_time, b.start_time);
  swap(a.is_super, b.is_super);
  swap(a.__isset, b.__isset);
}

TSessionInfo::TSessionInfo(const TSessionInfo& other381) {
  user = other381.user;
  database = other381.database;
  start_time = other381.start_time;
  is_super = other381.is_super;
  __isset = other381.__isset;
}
TSessionInfo& TSessionInfo::operator=(const TSessionInfo& other382) {
  user = other382.user;
  database = other382.database;
  start_time = other382.start_time;
  is_super = other382.is_super;
  __isset = other382.__isset;
  return *this;
}
void TSessionInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSessionInfo(";
  out << "user=" << to_string(user);
  out << ", " << "database=" << to_string(database);
  out << ", " << "start_time=" << to_string(start_time);
  out << ", " << "is_super=" << to_string(is_super);
  out << ")";
}


TGeoFileLayerInfo::~TGeoFileLayerInfo() noexcept {
}


void TGeoFileLayerInfo::__set_name(const std::string& val) {
  this->name = val;
}

void TGeoFileLayerInfo::__set_contents(const TGeoFileLayerContents::type val) {
  this->contents = val;
}
std::ostream& operator<<(std::ostream& out, const TGeoFileLayerInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGeoFileLayerInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast383;
          xfer += iprot->readI32(ecast383);
          this->contents = static_cast<TGeoFileLayerContents::type>(ecast383);
          this->__isset.contents = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGeoFileLayerInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGeoFileLayerInfo");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contents", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->contents));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGeoFileLayerInfo &a, TGeoFileLayerInfo &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.contents, b.contents);
  swap(a.__isset, b.__isset);
}

TGeoFileLayerInfo::TGeoFileLayerInfo(const TGeoFileLayerInfo& other384) {
  name = other384.name;
  contents = other384.contents;
  __isset = other384.__isset;
}
TGeoFileLayerInfo& TGeoFileLayerInfo::operator=(const TGeoFileLayerInfo& other385) {
  name = other385.name;
  contents = other385.contents;
  __isset = other385.__isset;
  return *this;
}
void TGeoFileLayerInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGeoFileLayerInfo(";
  out << "name=" << to_string(name);
  out << ", " << "contents=" << to_string(contents);
  out << ")";
}


TTableEpochInfo::~TTableEpochInfo() noexcept {
}


void TTableEpochInfo::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TTableEpochInfo::__set_table_epoch(const int32_t val) {
  this->table_epoch = val;
}

void TTableEpochInfo::__set_leaf_index(const int32_t val) {
  this->leaf_index = val;
}
std::ostream& operator<<(std::ostream& out, const TTableEpochInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableEpochInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_epoch);
          this->__isset.table_epoch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->leaf_index);
          this->__isset.leaf_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableEpochInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableEpochInfo");

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_epoch", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->table_epoch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("leaf_index", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->leaf_index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableEpochInfo &a, TTableEpochInfo &b) {
  using ::std::swap;
  swap(a.table_id, b.table_id);
  swap(a.table_epoch, b.table_epoch);
  swap(a.leaf_index, b.leaf_index);
  swap(a.__isset, b.__isset);
}

TTableEpochInfo::TTableEpochInfo(const TTableEpochInfo& other386) noexcept {
  table_id = other386.table_id;
  table_epoch = other386.table_epoch;
  leaf_index = other386.leaf_index;
  __isset = other386.__isset;
}
TTableEpochInfo& TTableEpochInfo::operator=(const TTableEpochInfo& other387) noexcept {
  table_id = other387.table_id;
  table_epoch = other387.table_epoch;
  leaf_index = other387.leaf_index;
  __isset = other387.__isset;
  return *this;
}
void TTableEpochInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableEpochInfo(";
  out << "table_id=" << to_string(table_id);
  out << ", " << "table_epoch=" << to_string(table_epoch);
  out << ", " << "leaf_index=" << to_string(leaf_index);
  out << ")";
}


TCustomExpression::~TCustomExpression() noexcept {
}


void TCustomExpression::__set_id(const int32_t val) {
  this->id = val;
}

void TCustomExpression::__set_name(const std::string& val) {
  this->name = val;
}

void TCustomExpression::__set_expression_json(const std::string& val) {
  this->expression_json = val;
}

void TCustomExpression::__set_data_source_type(const TDataSourceType::type val) {
  this->data_source_type = val;
}

void TCustomExpression::__set_data_source_id(const int32_t val) {
  this->data_source_id = val;
}

void TCustomExpression::__set_is_deleted(const bool val) {
  this->is_deleted = val;
}

void TCustomExpression::__set_data_source_name(const std::string& val) {
  this->data_source_name = val;
}
std::ostream& operator<<(std::ostream& out, const TCustomExpression& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCustomExpression::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expression_json);
          this->__isset.expression_json = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast388;
          xfer += iprot->readI32(ecast388);
          this->data_source_type = static_cast<TDataSourceType::type>(ecast388);
          this->__isset.data_source_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->data_source_id);
          this->__isset.data_source_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_deleted);
          this->__isset.is_deleted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data_source_name);
          this->__isset.data_source_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCustomExpression::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCustomExpression");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expression_json", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->expression_json);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data_source_type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(static_cast<int32_t>(this->data_source_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data_source_id", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->data_source_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_deleted", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->is_deleted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data_source_name", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->data_source_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCustomExpression &a, TCustomExpression &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.expression_json, b.expression_json);
  swap(a.data_source_type, b.data_source_type);
  swap(a.data_source_id, b.data_source_id);
  swap(a.is_deleted, b.is_deleted);
  swap(a.data_source_name, b.data_source_name);
  swap(a.__isset, b.__isset);
}

TCustomExpression::TCustomExpression(const TCustomExpression& other389) {
  id = other389.id;
  name = other389.name;
  expression_json = other389.expression_json;
  data_source_type = other389.data_source_type;
  data_source_id = other389.data_source_id;
  is_deleted = other389.is_deleted;
  data_source_name = other389.data_source_name;
  __isset = other389.__isset;
}
TCustomExpression& TCustomExpression::operator=(const TCustomExpression& other390) {
  id = other390.id;
  name = other390.name;
  expression_json = other390.expression_json;
  data_source_type = other390.data_source_type;
  data_source_id = other390.data_source_id;
  is_deleted = other390.is_deleted;
  data_source_name = other390.data_source_name;
  __isset = other390.__isset;
  return *this;
}
void TCustomExpression::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCustomExpression(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "expression_json=" << to_string(expression_json);
  out << ", " << "data_source_type=" << to_string(data_source_type);
  out << ", " << "data_source_id=" << to_string(data_source_id);
  out << ", " << "is_deleted=" << to_string(is_deleted);
  out << ", " << "data_source_name=" << to_string(data_source_name);
  out << ")";
}


TQueryInfo::~TQueryInfo() noexcept {
}


void TQueryInfo::__set_query_session_id(const std::string& val) {
  this->query_session_id = val;
}

void TQueryInfo::__set_query_public_session_id(const std::string& val) {
  this->query_public_session_id = val;
}

void TQueryInfo::__set_current_status(const std::string& val) {
  this->current_status = val;
}

void TQueryInfo::__set_executor_id(const int32_t val) {
  this->executor_id = val;
}

void TQueryInfo::__set_submitted(const std::string& val) {
  this->submitted = val;
}

void TQueryInfo::__set_query_str(const std::string& val) {
  this->query_str = val;
}

void TQueryInfo::__set_login_name(const std::string& val) {
  this->login_name = val;
}

void TQueryInfo::__set_client_address(const std::string& val) {
  this->client_address = val;
}

void TQueryInfo::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void TQueryInfo::__set_exec_device_type(const std::string& val) {
  this->exec_device_type = val;
}
std::ostream& operator<<(std::ostream& out, const TQueryInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TQueryInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->query_session_id);
          this->__isset.query_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->query_public_session_id);
          this->__isset.query_public_session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->current_status);
          this->__isset.current_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->executor_id);
          this->__isset.executor_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->submitted);
          this->__isset.submitted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->query_str);
          this->__isset.query_str = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->login_name);
          this->__isset.login_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client_address);
          this->__isset.client_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->exec_device_type);
          this->__isset.exec_device_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TQueryInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TQueryInfo");

  xfer += oprot->writeFieldBegin("query_session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->query_session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("query_public_session_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->query_public_session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("current_status", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->current_status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("executor_id", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->executor_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("submitted", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->submitted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("query_str", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->query_str);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("login_name", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->login_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("client_address", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->client_address);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exec_device_type", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->exec_device_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TQueryInfo &a, TQueryInfo &b) {
  using ::std::swap;
  swap(a.query_session_id, b.query_session_id);
  swap(a.query_public_session_id, b.query_public_session_id);
  swap(a.current_status, b.current_status);
  swap(a.executor_id, b.executor_id);
  swap(a.submitted, b.submitted);
  swap(a.query_str, b.query_str);
  swap(a.login_name, b.login_name);
  swap(a.client_address, b.client_address);
  swap(a.db_name, b.db_name);
  swap(a.exec_device_type, b.exec_device_type);
  swap(a.__isset, b.__isset);
}

TQueryInfo::TQueryInfo(const TQueryInfo& other391) {
  query_session_id = other391.query_session_id;
  query_public_session_id = other391.query_public_session_id;
  current_status = other391.current_status;
  executor_id = other391.executor_id;
  submitted = other391.submitted;
  query_str = other391.query_str;
  login_name = other391.login_name;
  client_address = other391.client_address;
  db_name = other391.db_name;
  exec_device_type = other391.exec_device_type;
  __isset = other391.__isset;
}
TQueryInfo& TQueryInfo::operator=(const TQueryInfo& other392) {
  query_session_id = other392.query_session_id;
  query_public_session_id = other392.query_public_session_id;
  current_status = other392.current_status;
  executor_id = other392.executor_id;
  submitted = other392.submitted;
  query_str = other392.query_str;
  login_name = other392.login_name;
  client_address = other392.client_address;
  db_name = other392.db_name;
  exec_device_type = other392.exec_device_type;
  __isset = other392.__isset;
  return *this;
}
void TQueryInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TQueryInfo(";
  out << "query_session_id=" << to_string(query_session_id);
  out << ", " << "query_public_session_id=" << to_string(query_public_session_id);
  out << ", " << "current_status=" << to_string(current_status);
  out << ", " << "executor_id=" << to_string(executor_id);
  out << ", " << "submitted=" << to_string(submitted);
  out << ", " << "query_str=" << to_string(query_str);
  out << ", " << "login_name=" << to_string(login_name);
  out << ", " << "client_address=" << to_string(client_address);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "exec_device_type=" << to_string(exec_device_type);
  out << ")";
}


TLeafInfo::~TLeafInfo() noexcept {
}


void TLeafInfo::__set_leaf_id(const int32_t val) {
  this->leaf_id = val;
}

void TLeafInfo::__set_num_leaves(const int32_t val) {
  this->num_leaves = val;
}
std::ostream& operator<<(std::ostream& out, const TLeafInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TLeafInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->leaf_id);
          this->__isset.leaf_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_leaves);
          this->__isset.num_leaves = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TLeafInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLeafInfo");

  xfer += oprot->writeFieldBegin("leaf_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->leaf_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_leaves", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num_leaves);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLeafInfo &a, TLeafInfo &b) {
  using ::std::swap;
  swap(a.leaf_id, b.leaf_id);
  swap(a.num_leaves, b.num_leaves);
  swap(a.__isset, b.__isset);
}

TLeafInfo::TLeafInfo(const TLeafInfo& other393) noexcept {
  leaf_id = other393.leaf_id;
  num_leaves = other393.num_leaves;
  __isset = other393.__isset;
}
TLeafInfo& TLeafInfo::operator=(const TLeafInfo& other394) noexcept {
  leaf_id = other394.leaf_id;
  num_leaves = other394.num_leaves;
  __isset = other394.__isset;
  return *this;
}
void TLeafInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLeafInfo(";
  out << "leaf_id=" << to_string(leaf_id);
  out << ", " << "num_leaves=" << to_string(num_leaves);
  out << ")";
}


TImmerseUserMetadata::~TImmerseUserMetadata() noexcept {
}


void TImmerseUserMetadata::__set_username(const std::string& val) {
  this->username = val;
}

void TImmerseUserMetadata::__set_immerse_metadata_json(const std::string& val) {
  this->immerse_metadata_json = val;
}
std::ostream& operator<<(std::ostream& out, const TImmerseUserMetadata& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TImmerseUserMetadata::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->immerse_metadata_json);
          this->__isset.immerse_metadata_json = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TImmerseUserMetadata::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TImmerseUserMetadata");

  xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->username);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("immerse_metadata_json", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->immerse_metadata_json);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TImmerseUserMetadata &a, TImmerseUserMetadata &b) {
  using ::std::swap;
  swap(a.username, b.username);
  swap(a.immerse_metadata_json, b.immerse_metadata_json);
  swap(a.__isset, b.__isset);
}

TImmerseUserMetadata::TImmerseUserMetadata(const TImmerseUserMetadata& other395) {
  username = other395.username;
  immerse_metadata_json = other395.immerse_metadata_json;
  __isset = other395.__isset;
}
TImmerseUserMetadata& TImmerseUserMetadata::operator=(const TImmerseUserMetadata& other396) {
  username = other396.username;
  immerse_metadata_json = other396.immerse_metadata_json;
  __isset = other396.__isset;
  return *this;
}
void TImmerseUserMetadata::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TImmerseUserMetadata(";
  out << "username=" << to_string(username);
  out << ", " << "immerse_metadata_json=" << to_string(immerse_metadata_json);
  out << ")";
}


TUserInfo::~TUserInfo() noexcept {
}


void TUserInfo::__set_username(const std::string& val) {
  this->username = val;
}

void TUserInfo::__set_roles(const std::vector<std::string> & val) {
  this->roles = val;
}

void TUserInfo::__set_immerse_metadata_json(const std::string& val) {
  this->immerse_metadata_json = val;
}
std::ostream& operator<<(std::ostream& out, const TUserInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TUserInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->roles.clear();
            uint32_t _size397;
            ::apache::thrift::protocol::TType _etype400;
            xfer += iprot->readListBegin(_etype400, _size397);
            this->roles.resize(_size397);
            uint32_t _i401;
            for (_i401 = 0; _i401 < _size397; ++_i401)
            {
              xfer += iprot->readString(this->roles[_i401]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.roles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->immerse_metadata_json);
          this->__isset.immerse_metadata_json = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TUserInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUserInfo");

  xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->username);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roles", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->roles.size()));
    std::vector<std::string> ::const_iterator _iter402;
    for (_iter402 = this->roles.begin(); _iter402 != this->roles.end(); ++_iter402)
    {
      xfer += oprot->writeString((*_iter402));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("immerse_metadata_json", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->immerse_metadata_json);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUserInfo &a, TUserInfo &b) {
  using ::std::swap;
  swap(a.username, b.username);
  swap(a.roles, b.roles);
  swap(a.immerse_metadata_json, b.immerse_metadata_json);
  swap(a.__isset, b.__isset);
}

TUserInfo::TUserInfo(const TUserInfo& other403) {
  username = other403.username;
  roles = other403.roles;
  immerse_metadata_json = other403.immerse_metadata_json;
  __isset = other403.__isset;
}
TUserInfo& TUserInfo::operator=(const TUserInfo& other404) {
  username = other404.username;
  roles = other404.roles;
  immerse_metadata_json = other404.immerse_metadata_json;
  __isset = other404.__isset;
  return *this;
}
void TUserInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUserInfo(";
  out << "username=" << to_string(username);
  out << ", " << "roles=" << to_string(roles);
  out << ", " << "immerse_metadata_json=" << to_string(immerse_metadata_json);
  out << ")";
}


