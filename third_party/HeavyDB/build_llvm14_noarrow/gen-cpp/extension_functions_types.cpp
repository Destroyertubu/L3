/**
 * Autogenerated by Thrift Compiler (0.19.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "extension_functions_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kTExtArgumentTypeValues[] = {
  TExtArgumentType::Int8,
  TExtArgumentType::Int16,
  TExtArgumentType::Int32,
  TExtArgumentType::Int64,
  TExtArgumentType::Float,
  TExtArgumentType::Double,
  TExtArgumentType::Void,
  TExtArgumentType::PInt8,
  TExtArgumentType::PInt16,
  TExtArgumentType::PInt32,
  TExtArgumentType::PInt64,
  TExtArgumentType::PFloat,
  TExtArgumentType::PDouble,
  TExtArgumentType::PBool,
  TExtArgumentType::Bool,
  TExtArgumentType::ArrayInt8,
  TExtArgumentType::ArrayInt16,
  TExtArgumentType::ArrayInt32,
  TExtArgumentType::ArrayInt64,
  TExtArgumentType::ArrayFloat,
  TExtArgumentType::ArrayDouble,
  TExtArgumentType::ArrayBool,
  TExtArgumentType::GeoPoint,
  TExtArgumentType::GeoLineString,
  TExtArgumentType::Cursor,
  TExtArgumentType::GeoPolygon,
  TExtArgumentType::GeoMultiPolygon,
  TExtArgumentType::ColumnInt8,
  TExtArgumentType::ColumnInt16,
  TExtArgumentType::ColumnInt32,
  TExtArgumentType::ColumnInt64,
  TExtArgumentType::ColumnFloat,
  TExtArgumentType::ColumnDouble,
  TExtArgumentType::ColumnBool,
  TExtArgumentType::TextEncodingNone,
  TExtArgumentType::TextEncodingDict,
  TExtArgumentType::ColumnListInt8,
  TExtArgumentType::ColumnListInt16,
  TExtArgumentType::ColumnListInt32,
  TExtArgumentType::ColumnListInt64,
  TExtArgumentType::ColumnListFloat,
  TExtArgumentType::ColumnListDouble,
  TExtArgumentType::ColumnListBool,
  TExtArgumentType::ColumnTextEncodingDict,
  TExtArgumentType::ColumnListTextEncodingDict,
  TExtArgumentType::ColumnTimestamp,
  TExtArgumentType::Timestamp,
  TExtArgumentType::ColumnArrayInt8,
  TExtArgumentType::ColumnArrayInt16,
  TExtArgumentType::ColumnArrayInt32,
  TExtArgumentType::ColumnArrayInt64,
  TExtArgumentType::ColumnArrayFloat,
  TExtArgumentType::ColumnArrayDouble,
  TExtArgumentType::ColumnArrayBool,
  TExtArgumentType::ColumnListArrayInt8,
  TExtArgumentType::ColumnListArrayInt16,
  TExtArgumentType::ColumnListArrayInt32,
  TExtArgumentType::ColumnListArrayInt64,
  TExtArgumentType::ColumnListArrayFloat,
  TExtArgumentType::ColumnListArrayDouble,
  TExtArgumentType::ColumnListArrayBool,
  TExtArgumentType::GeoMultiLineString,
  TExtArgumentType::ArrayTextEncodingNone,
  TExtArgumentType::ColumnTextEncodingNone,
  TExtArgumentType::ColumnListTextEncodingNone,
  TExtArgumentType::ColumnArrayTextEncodingNone,
  TExtArgumentType::ColumnListArrayTextEncodingNone,
  TExtArgumentType::ArrayTextEncodingDict,
  TExtArgumentType::ColumnArrayTextEncodingDict,
  TExtArgumentType::ColumnListArrayTextEncodingDict,
  TExtArgumentType::GeoMultiPoint,
  TExtArgumentType::DayTimeInterval,
  TExtArgumentType::YearMonthTimeInterval,
  TExtArgumentType::ColumnGeoPoint,
  TExtArgumentType::ColumnGeoLineString,
  TExtArgumentType::ColumnGeoPolygon,
  TExtArgumentType::ColumnGeoMultiPoint,
  TExtArgumentType::ColumnGeoMultiLineString,
  TExtArgumentType::ColumnGeoMultiPolygon,
  TExtArgumentType::ColumnListGeoPoint,
  TExtArgumentType::ColumnListGeoLineString,
  TExtArgumentType::ColumnListGeoPolygon,
  TExtArgumentType::ColumnListGeoMultiPoint,
  TExtArgumentType::ColumnListGeoMultiLineString,
  TExtArgumentType::ColumnListGeoMultiPolygon
};
const char* _kTExtArgumentTypeNames[] = {
  "Int8",
  "Int16",
  "Int32",
  "Int64",
  "Float",
  "Double",
  "Void",
  "PInt8",
  "PInt16",
  "PInt32",
  "PInt64",
  "PFloat",
  "PDouble",
  "PBool",
  "Bool",
  "ArrayInt8",
  "ArrayInt16",
  "ArrayInt32",
  "ArrayInt64",
  "ArrayFloat",
  "ArrayDouble",
  "ArrayBool",
  "GeoPoint",
  "GeoLineString",
  "Cursor",
  "GeoPolygon",
  "GeoMultiPolygon",
  "ColumnInt8",
  "ColumnInt16",
  "ColumnInt32",
  "ColumnInt64",
  "ColumnFloat",
  "ColumnDouble",
  "ColumnBool",
  "TextEncodingNone",
  "TextEncodingDict",
  "ColumnListInt8",
  "ColumnListInt16",
  "ColumnListInt32",
  "ColumnListInt64",
  "ColumnListFloat",
  "ColumnListDouble",
  "ColumnListBool",
  "ColumnTextEncodingDict",
  "ColumnListTextEncodingDict",
  "ColumnTimestamp",
  "Timestamp",
  "ColumnArrayInt8",
  "ColumnArrayInt16",
  "ColumnArrayInt32",
  "ColumnArrayInt64",
  "ColumnArrayFloat",
  "ColumnArrayDouble",
  "ColumnArrayBool",
  "ColumnListArrayInt8",
  "ColumnListArrayInt16",
  "ColumnListArrayInt32",
  "ColumnListArrayInt64",
  "ColumnListArrayFloat",
  "ColumnListArrayDouble",
  "ColumnListArrayBool",
  "GeoMultiLineString",
  "ArrayTextEncodingNone",
  "ColumnTextEncodingNone",
  "ColumnListTextEncodingNone",
  "ColumnArrayTextEncodingNone",
  "ColumnListArrayTextEncodingNone",
  "ArrayTextEncodingDict",
  "ColumnArrayTextEncodingDict",
  "ColumnListArrayTextEncodingDict",
  "GeoMultiPoint",
  "DayTimeInterval",
  "YearMonthTimeInterval",
  "ColumnGeoPoint",
  "ColumnGeoLineString",
  "ColumnGeoPolygon",
  "ColumnGeoMultiPoint",
  "ColumnGeoMultiLineString",
  "ColumnGeoMultiPolygon",
  "ColumnListGeoPoint",
  "ColumnListGeoLineString",
  "ColumnListGeoPolygon",
  "ColumnListGeoMultiPoint",
  "ColumnListGeoMultiLineString",
  "ColumnListGeoMultiPolygon"
};
const std::map<int, const char*> _TExtArgumentType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(85, _kTExtArgumentTypeValues, _kTExtArgumentTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TExtArgumentType::type& val) {
  std::map<int, const char*>::const_iterator it = _TExtArgumentType_VALUES_TO_NAMES.find(val);
  if (it != _TExtArgumentType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TExtArgumentType::type& val) {
  std::map<int, const char*>::const_iterator it = _TExtArgumentType_VALUES_TO_NAMES.find(val);
  if (it != _TExtArgumentType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTOutputBufferSizeTypeValues[] = {
  TOutputBufferSizeType::kConstant,
  TOutputBufferSizeType::kUserSpecifiedConstantParameter,
  TOutputBufferSizeType::kUserSpecifiedRowMultiplier,
  TOutputBufferSizeType::kTableFunctionSpecifiedParameter,
  TOutputBufferSizeType::kPreFlightParameter
};
const char* _kTOutputBufferSizeTypeNames[] = {
  "kConstant",
  "kUserSpecifiedConstantParameter",
  "kUserSpecifiedRowMultiplier",
  "kTableFunctionSpecifiedParameter",
  "kPreFlightParameter"
};
const std::map<int, const char*> _TOutputBufferSizeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTOutputBufferSizeTypeValues, _kTOutputBufferSizeTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TOutputBufferSizeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TOutputBufferSizeType_VALUES_TO_NAMES.find(val);
  if (it != _TOutputBufferSizeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TOutputBufferSizeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TOutputBufferSizeType_VALUES_TO_NAMES.find(val);
  if (it != _TOutputBufferSizeType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


TUserDefinedFunction::~TUserDefinedFunction() noexcept {
}


void TUserDefinedFunction::__set_name(const std::string& val) {
  this->name = val;
}

void TUserDefinedFunction::__set_argTypes(const std::vector<TExtArgumentType::type> & val) {
  this->argTypes = val;
}

void TUserDefinedFunction::__set_retType(const TExtArgumentType::type val) {
  this->retType = val;
}

void TUserDefinedFunction::__set_annotations(const std::vector<std::map<std::string, std::string> > & val) {
  this->annotations = val;
}
std::ostream& operator<<(std::ostream& out, const TUserDefinedFunction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TUserDefinedFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->argTypes.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->argTypes.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              int32_t ecast5;
              xfer += iprot->readI32(ecast5);
              this->argTypes[_i4] = static_cast<TExtArgumentType::type>(ecast5);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.argTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast6;
          xfer += iprot->readI32(ecast6);
          this->retType = static_cast<TExtArgumentType::type>(ecast6);
          this->__isset.retType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->annotations.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _etype10;
            xfer += iprot->readListBegin(_etype10, _size7);
            this->annotations.resize(_size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              {
                this->annotations[_i11].clear();
                uint32_t _size12;
                ::apache::thrift::protocol::TType _ktype13;
                ::apache::thrift::protocol::TType _vtype14;
                xfer += iprot->readMapBegin(_ktype13, _vtype14, _size12);
                uint32_t _i16;
                for (_i16 = 0; _i16 < _size12; ++_i16)
                {
                  std::string _key17;
                  xfer += iprot->readString(_key17);
                  std::string& _val18 = this->annotations[_i11][_key17];
                  xfer += iprot->readString(_val18);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.annotations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TUserDefinedFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUserDefinedFunction");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("argTypes", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->argTypes.size()));
    std::vector<TExtArgumentType::type> ::const_iterator _iter19;
    for (_iter19 = this->argTypes.begin(); _iter19 != this->argTypes.end(); ++_iter19)
    {
      xfer += oprot->writeI32(static_cast<int32_t>((*_iter19)));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("retType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(static_cast<int32_t>(this->retType));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("annotations", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->annotations.size()));
    std::vector<std::map<std::string, std::string> > ::const_iterator _iter20;
    for (_iter20 = this->annotations.begin(); _iter20 != this->annotations.end(); ++_iter20)
    {
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter20).size()));
        std::map<std::string, std::string> ::const_iterator _iter21;
        for (_iter21 = (*_iter20).begin(); _iter21 != (*_iter20).end(); ++_iter21)
        {
          xfer += oprot->writeString(_iter21->first);
          xfer += oprot->writeString(_iter21->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUserDefinedFunction &a, TUserDefinedFunction &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.argTypes, b.argTypes);
  swap(a.retType, b.retType);
  swap(a.annotations, b.annotations);
  swap(a.__isset, b.__isset);
}

TUserDefinedFunction::TUserDefinedFunction(const TUserDefinedFunction& other22) {
  name = other22.name;
  argTypes = other22.argTypes;
  retType = other22.retType;
  annotations = other22.annotations;
  __isset = other22.__isset;
}
TUserDefinedFunction& TUserDefinedFunction::operator=(const TUserDefinedFunction& other23) {
  name = other23.name;
  argTypes = other23.argTypes;
  retType = other23.retType;
  annotations = other23.annotations;
  __isset = other23.__isset;
  return *this;
}
void TUserDefinedFunction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUserDefinedFunction(";
  out << "name=" << to_string(name);
  out << ", " << "argTypes=" << to_string(argTypes);
  out << ", " << "retType=" << to_string(retType);
  out << ", " << "annotations=" << to_string(annotations);
  out << ")";
}


TUserDefinedTableFunction::~TUserDefinedTableFunction() noexcept {
}


void TUserDefinedTableFunction::__set_name(const std::string& val) {
  this->name = val;
}

void TUserDefinedTableFunction::__set_sizerType(const TOutputBufferSizeType::type val) {
  this->sizerType = val;
}

void TUserDefinedTableFunction::__set_sizerArgPos(const int32_t val) {
  this->sizerArgPos = val;
}

void TUserDefinedTableFunction::__set_inputArgTypes(const std::vector<TExtArgumentType::type> & val) {
  this->inputArgTypes = val;
}

void TUserDefinedTableFunction::__set_outputArgTypes(const std::vector<TExtArgumentType::type> & val) {
  this->outputArgTypes = val;
}

void TUserDefinedTableFunction::__set_sqlArgTypes(const std::vector<TExtArgumentType::type> & val) {
  this->sqlArgTypes = val;
}

void TUserDefinedTableFunction::__set_annotations(const std::vector<std::map<std::string, std::string> > & val) {
  this->annotations = val;
}
std::ostream& operator<<(std::ostream& out, const TUserDefinedTableFunction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TUserDefinedTableFunction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast24;
          xfer += iprot->readI32(ecast24);
          this->sizerType = static_cast<TOutputBufferSizeType::type>(ecast24);
          this->__isset.sizerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sizerArgPos);
          this->__isset.sizerArgPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->inputArgTypes.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _etype28;
            xfer += iprot->readListBegin(_etype28, _size25);
            this->inputArgTypes.resize(_size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              int32_t ecast30;
              xfer += iprot->readI32(ecast30);
              this->inputArgTypes[_i29] = static_cast<TExtArgumentType::type>(ecast30);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.inputArgTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->outputArgTypes.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->outputArgTypes.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              int32_t ecast36;
              xfer += iprot->readI32(ecast36);
              this->outputArgTypes[_i35] = static_cast<TExtArgumentType::type>(ecast36);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.outputArgTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sqlArgTypes.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->sqlArgTypes.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              int32_t ecast42;
              xfer += iprot->readI32(ecast42);
              this->sqlArgTypes[_i41] = static_cast<TExtArgumentType::type>(ecast42);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sqlArgTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->annotations.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->annotations.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              {
                this->annotations[_i47].clear();
                uint32_t _size48;
                ::apache::thrift::protocol::TType _ktype49;
                ::apache::thrift::protocol::TType _vtype50;
                xfer += iprot->readMapBegin(_ktype49, _vtype50, _size48);
                uint32_t _i52;
                for (_i52 = 0; _i52 < _size48; ++_i52)
                {
                  std::string _key53;
                  xfer += iprot->readString(_key53);
                  std::string& _val54 = this->annotations[_i47][_key53];
                  xfer += iprot->readString(_val54);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.annotations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TUserDefinedTableFunction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUserDefinedTableFunction");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sizerType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->sizerType));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sizerArgPos", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->sizerArgPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inputArgTypes", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->inputArgTypes.size()));
    std::vector<TExtArgumentType::type> ::const_iterator _iter55;
    for (_iter55 = this->inputArgTypes.begin(); _iter55 != this->inputArgTypes.end(); ++_iter55)
    {
      xfer += oprot->writeI32(static_cast<int32_t>((*_iter55)));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputArgTypes", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->outputArgTypes.size()));
    std::vector<TExtArgumentType::type> ::const_iterator _iter56;
    for (_iter56 = this->outputArgTypes.begin(); _iter56 != this->outputArgTypes.end(); ++_iter56)
    {
      xfer += oprot->writeI32(static_cast<int32_t>((*_iter56)));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sqlArgTypes", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->sqlArgTypes.size()));
    std::vector<TExtArgumentType::type> ::const_iterator _iter57;
    for (_iter57 = this->sqlArgTypes.begin(); _iter57 != this->sqlArgTypes.end(); ++_iter57)
    {
      xfer += oprot->writeI32(static_cast<int32_t>((*_iter57)));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("annotations", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->annotations.size()));
    std::vector<std::map<std::string, std::string> > ::const_iterator _iter58;
    for (_iter58 = this->annotations.begin(); _iter58 != this->annotations.end(); ++_iter58)
    {
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter58).size()));
        std::map<std::string, std::string> ::const_iterator _iter59;
        for (_iter59 = (*_iter58).begin(); _iter59 != (*_iter58).end(); ++_iter59)
        {
          xfer += oprot->writeString(_iter59->first);
          xfer += oprot->writeString(_iter59->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TUserDefinedTableFunction &a, TUserDefinedTableFunction &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.sizerType, b.sizerType);
  swap(a.sizerArgPos, b.sizerArgPos);
  swap(a.inputArgTypes, b.inputArgTypes);
  swap(a.outputArgTypes, b.outputArgTypes);
  swap(a.sqlArgTypes, b.sqlArgTypes);
  swap(a.annotations, b.annotations);
  swap(a.__isset, b.__isset);
}

TUserDefinedTableFunction::TUserDefinedTableFunction(const TUserDefinedTableFunction& other60) {
  name = other60.name;
  sizerType = other60.sizerType;
  sizerArgPos = other60.sizerArgPos;
  inputArgTypes = other60.inputArgTypes;
  outputArgTypes = other60.outputArgTypes;
  sqlArgTypes = other60.sqlArgTypes;
  annotations = other60.annotations;
  __isset = other60.__isset;
}
TUserDefinedTableFunction& TUserDefinedTableFunction::operator=(const TUserDefinedTableFunction& other61) {
  name = other61.name;
  sizerType = other61.sizerType;
  sizerArgPos = other61.sizerArgPos;
  inputArgTypes = other61.inputArgTypes;
  outputArgTypes = other61.outputArgTypes;
  sqlArgTypes = other61.sqlArgTypes;
  annotations = other61.annotations;
  __isset = other61.__isset;
  return *this;
}
void TUserDefinedTableFunction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUserDefinedTableFunction(";
  out << "name=" << to_string(name);
  out << ", " << "sizerType=" << to_string(sizerType);
  out << ", " << "sizerArgPos=" << to_string(sizerArgPos);
  out << ", " << "inputArgTypes=" << to_string(inputArgTypes);
  out << ", " << "outputArgTypes=" << to_string(outputArgTypes);
  out << ", " << "sqlArgTypes=" << to_string(sqlArgTypes);
  out << ", " << "annotations=" << to_string(annotations);
  out << ")";
}


